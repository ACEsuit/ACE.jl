        - 
        - module Random
        - 
        - # TODO: rename rand_radial -> rand???
        - 
        - import LinearAlgebra: norm
        - import SHIPs: ScalarBasis, ZList, rand_radial, scaling
        - 
        - using Random: shuffle
        - using JuLIP: JVecF
        - using JuLIP.MLIPs: combine
        - using StaticArrays: @SMatrix
        - 
        - export rand_nhd, rand_sym, randcoeffs, randcombine
        - 
        - # -------------------------------------------
        - #   random configurations
        - # TODO: JVecF is hard-coded
        - function rand_sphere()
        0    R = randn(JVecF)
        0    return R / norm(R)
        - end
        - 
        - # TODO: this could be rand(PSH1BasisFcn) ...
        - #       rand_sphere = rand(SphericalHarmonics)
   403008 rand_vec(J::ScalarBasis) where T = rand_radial(J) *  rand_sphere()
        - rand_vec(J::ScalarBasis, N::Integer) = [ rand_vec(J) for _ = 1:N ]
        - 
        - # -> rand_config?
        - function rand_nhd(Nat, J::ScalarBasis, species = :X)
 11126468    zlist = ZList(species)
       48    Rs = [ rand_vec(J) for _ = 1:Nat ]
      160    Zs = [ rand(zlist.list) for _ = 1:Nat ]
        0    z0 = rand(zlist.list)
       32    return Rs, Zs, z0
        - end
        - 
        - # --------------------------------------------------------------
        - # random operations on neighbourhoods, mostly for testing
        - 
        - function rand_perm(Rs, Zs)
        -    @assert length(Rs) == length(Zs)
        -    p = shuffle(1:length(Rs))
        -    return Rs[p], Zs[p]
        - end
        - 
        - function rand_rot(Rs, Zs)
        -    @assert length(Rs) == length(Zs)
        -    K = (@SMatrix rand(3,3)) .- 0.5
        -    K = K - K'
        -    Q = exp(K)
        -    return [ Q * R for R in Rs ], Zs
        - end
        - 
        - rand_refl(Rs, Zs) = (-1) .* Rs, Zs
        - 
        - rand_sym(Rs, Zs) = rand_refl(rand_rot(rand_perm(Rs, Zs)...)...)
        - 
        - 
        - # -------------------------------------------
        - #     random potentials
        - 
        - # TODO: we have an issue with eltypes that needs to be fixed!!!
        - 
        - function randcoeffs(basis; diff = 2)
        0    ww = scaling(basis, diff)
     5424    c = 2 * (rand(real(eltype(basis)), length(basis)) .- 0.5) ./ ww
     1808    return c / norm(c)
        - end
        - 
109402722 randcombine(basis; diff = 2) =
        -    combine(basis, randcoeffs(basis; diff = diff))
        - 
        - # # move to utility???
        - # function rand(::Type{SHIPs.RPI.RPIBasis}; kwargs...)
        - #
        - # end
        - 
        - end
        - 
