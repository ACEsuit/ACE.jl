        - 
        - module Tree
        - 
        - include("extimports.jl")
        - include("shipimports.jl")
        - 
        - using Combinatorics: combinations, partitions
        - 
        - import SHIPs: InnerPIBasis
        - 
        - const ETNode{TI} = Tuple{TI,TI}
        - 
     2224 ETNode{TI}(i1, i2) where {TI} = ( TI(i1), TI(i2) )
        - 
        - 
        - struct EvalTree{T, TI}
     2752    nodes::Vector{ETNode{TI}}
        -    coeffs::Vector{T}
        -    num1::TI
        -    numstore::TI
        - end
        - 
        - 
        - struct TreePIPot{T, TI, NZ, TB} <: SitePotential
   168479    basis1p::TB
        -    trees::NTuple{NZ, EvalTree{T, TI}}
        - end
        - 
        - i2z(V::TreePIPot, i::Integer) = i2z(V.basis1p, i)
        - z2i(V::TreePIPot, z::AtomicNumber) = z2i(V.basis1p, z)
        - numz(V::TreePIPot) = numz(V.basis1p)
        - 
        - cutoff(V::TreePIPot) = cutoff(V.basis1p)
        - 
        - Base.eltype(V::TreePIPot{T}) where {T} = real(T)
        - 
        - _maxstore(V::TreePIPot) = maximum( tree.numstore for tree in V.trees )
        - 
        - Base.length(tree::EvalTree) = length(tree.nodes)
        - 
        - # ---------------------------------------------------------------------
        - #   construction codes
        - 
        - 
        - function TreePIPot(pipot::PIPotential; kwargs...)
123882731    trees = [ get_eval_tree(pipot.pibasis.inner[iz], pipot.coeffs[iz];
        -                            kwargs...)  for iz = 1:numz(pipot) ]
      160    return TreePIPot(pipot.pibasis.basis1p, tuple(trees...))
        - end
        - 
        - 
        - 
 11198276 _score_partition(p) = any(isnothing, p) ? Inf : 1000 * length(p) + maximum(p)
        - 
        - _get_ns(p, specnew) =
        -       [ findfirst(isequal(kk_), specnew)  for kk_ in p ]
        - 
        - function _find_partition(kk, specnew)
        -    # @show kk
  1045670    worstp = _get_ns([ [k] for k in kk ], specnew)
        0    @assert worstp == kk
        -    bestp = worstp
     7040    bestscore = _score_partition(bestp)
        - 
        0    for ip in partitions(1:length(kk))
  7581158       p = _get_ns([ kk[i] for i in ip ], specnew)
   118400       score = _score_partition(p)
 54539693       if !any(isnothing.(p)) && score < bestscore
        -          bestp = p
        0          bestscore = score
        -       end
        -    end
        - 
        0    return bestp
        - end
        - 
        - # return value is the number of fake nodes added to the tree
        - function _insert_partition!(nodes, coeffsnew, specnew,
        -                             kk, p,
        -                             ikk, coeffsN, specN,
        -                             TI = Int)
  1445745    if length(p) == 2
    28544       push!(nodes, ETNode{TI}(p[1], p[2]))
     7296       push!(coeffsnew, coeffsN[ikk])
     7296       push!(specnew, kk)
        0       return 0
        -    else
        -       # reduce the partition by pushing a new node
      320       push!(nodes, ETNode{TI}(p[1], p[2]))
        0       push!(coeffsnew, 0)
     1920       push!(specnew, sort(vcat(specnew[p[1]], specnew[p[2]])))
        -       # and now recurse with the reduced partition
     2880       return 1 + _insert_partition!(nodes, coeffsnew, specnew,
        -                          kk, vcat( [length(nodes)], p[3:end] ),
        -                          ikk, coeffsN, specN, TI)
        -    end
        - end
        - 
        - function get_eval_tree(inner::InnerPIBasis, coeffs;
        -                        filter = _->true,
        -                        TI = Int,
        -                        verbose = false)
        -    # make a list of all basis functions as vectors so we can search it
        -    # TODO: should also check the tuples are sorted lexicographically
 93054515    spec = [ inner.iAA2iA[iAA, 1:inner.orders[iAA]]
        -             for iAA = 1:length(inner) ]
     3776    @assert issorted(length.(spec))
        0    @assert all(issorted, spec)
        -    # we need to separate them into 1-p and many-p
     4672    spec1 = spec[ length.(spec) .== 1 ]
      160    coeffs1 = coeffs[1:length(spec1)]
        0    IN = (length(spec1)+1):length(spec)
     3648    specN = spec[IN]
     3648    coeffsN = coeffs[IN]
        - 
        -    # start assembling the tree
     2432    nodes = ETNode{TI}[]
     7296    sizehint!(nodes, length(inner))
       80    coeffsnew = Vector{eltype(coeffs)}()
     3712    sizehint!(coeffsnew, length(inner))
       80    specnew = Vector{Int}[]
     3712    sizehint!(specnew, length(inner))
        - 
        -    # add the full 1-particle basis (N=1) into the tree
        0    num1 = maximum(inner.iAA2iA)
        0    for i = 1:num1
    12336       push!(nodes, ETNode{TI}(i, 0))
    16800       push!(specnew, [i])
        -       # find that index in `spec`
    16800       ispec = findfirst(isequal([i]), spec1)
        0       if isnothing(ispec)
        0          push!(coeffsnew, 0)
        -       else
        0          push!(coeffsnew, coeffs1[ispec])
        -       end
        -    end
        - 
        -    # now we can construct the rest
        -    extranodes = 0
        0    for (ikk, kk) in enumerate(specN)
        -       # find a good partition of kk
        0       p = _find_partition(kk, specnew)
        0       extranodes += _insert_partition!(nodes, coeffsnew, specnew,
        -                                        kk, p, ikk, coeffsN, specN, TI)
        -    end
        - 
        0    verbose && @info("Extra nodes inserted into the tree: $extranodes")
        0    numstore = length(nodes)
        - 
        -    # re-organise the tree layout to minimise numstore
        0    nodesfinal, coeffsfinal, num1, numstore = _reorder_tree!(nodes, coeffsnew)
        - 
        0    return EvalTree(nodesfinal, coeffsfinal, TI(num1), TI(numstore))
        - end
        - 
        - 
        - function _reorder_tree!(nodes::Vector{ETNode{TI}}, coeffs::Vector{T}) where {TI, T}
        -    # collect all AA indices that are used anywhere in the tree
   178912    newinds = zeros(Int, length(nodes))
       80    newnodes = ETNode{TI}[]
       80    newcoeffs = T[]
        - 
        -    # inds2 = stage-2 indices, i.e. temporary storage
        -    # inds3 = stage-3 indices, i.e. no intermediate storage
    44944    inds2 = sort(unique([[ n[1] for n in nodes ]; [n[2] for n in nodes]]))
        - 
        -    # first add all 1p nodes
        0    for i = 1:length(nodes)
        0       n, c = nodes[i], coeffs[i]
        0       if (n[2] == 0) && ((c != 0) || (i in inds2))
        0          @assert n[1] == i
        0          newinds[i] = i
     8400          push!(newnodes, n)
     4288          push!(newcoeffs, c)
        -       end
        -    end
        0    num1 = length(newnodes)
        - 
        -    # next add the remaining dependent nodes
        0    for i = 1:length(nodes)
        0       n, c = nodes[i], coeffs[i]
        -       # not 1p basis && dependent node
        0       if (n[2] != 0) && (i in inds2)
     8256          push!(newnodes, ETNode{TI}(newinds[n[1]], newinds[n[2]]))
     4160          push!(newcoeffs, c)
        0          newinds[i] = length(newnodes)
        -       end
        -    end
        0    numstore = length(newnodes)
        - 
        -    # now go through one more time and add the independent nodes
        0    for i = 1:length(nodes)
        0       n, c = nodes[i], coeffs[i]
        0       if (n[2] != 0) && (newinds[i] == 0) && (c != 0)
    16448          push!(newnodes, ETNode{TI}(newinds[n[1]], newinds[n[2]]))
     8256          push!(newcoeffs, c)
        0          newinds[i] = length(newnodes)
        -       end
        -    end
        - 
       48    return newnodes, newcoeffs, num1, numstore
        - end
        - 
        - # ---------------------------------------------------------------------
        - #   evaluation codes
        - 
  4055150 alloc_temp(V::TreePIPot{T}, maxN::Integer) where {T} =
        -    (
        -    R = zeros(JVec{real(T)}, maxN),
        -    Z = zeros(AtomicNumber, maxN),
        -    tmp_basis1p = alloc_temp(V.basis1p),
        -    AA = zeros(eltype(V.basis1p), _maxstore(V))
        -     )
        - 
        - 
        - function evaluate!(tmp, V::TreePIPot, Rs, Zs, z0)
        -    iz0 = z2i(V, z0)
        -    AA = tmp.AA
        -    tree = V.trees[iz0]
        -    nodes = tree.nodes
        -    c = tree.coeffs
        - 
        -    # evaluate the 1-particle basis
        -    # this puts the first `tree.num1` 1-b (trivial) correlations into the
        -    # storage array, and from these we can build the rest
        -    evaluate!(AA, tmp.tmp_basis1p, V.basis1p, Rs, Zs, z0)
        - 
        -    # Stage 1: accumulate the first basis functions
        -    Es = zero(eltype(V))
        -    @inbounds for i = 1:tree.num1
        -       Es = muladd(c[i], real(AA[i]), Es)
        -    end
        - 
        -    # Stage 2:
        -    # go through the tree and store the intermediate results we need
        -    @inbounds @fastmath for i = (tree.num1+1):tree.numstore
        -       t = nodes[i]
        -       a = AA[t[1]] * AA[t[2]]
        -       AA[i] = a
        -       Es = muladd(c[i], real(a), Es)
        -    end
        - 
        -    # Stage 3:
        -    # continue going through the tree, but now we don't need to store
        -    # the new correlations since the later expressions don't depend
        -    # on them
        -    @inbounds @fastmath for i = (tree.numstore+1):length(tree)
        -       t = nodes[i]
        -       a = AA[t[1]] * AA[t[2]]
        -       Es = muladd(c[i], real(a), Es)
        -    end
        - 
        -    return Es
        - end
        - 
        - 
 13233459 alloc_temp_d(V::TreePIPot{T}, maxN::Integer) where {T} =
        -    (
        -    R = zeros(JVec{real(T)}, maxN),
        -    Z = zeros(AtomicNumber, maxN),
        -     dV = zeros(JVec{real(T)}, maxN),
        -    tmpd_basis1p = alloc_temp_d(V.basis1p),
        -    AA = zeros(eltype(V.basis1p), _maxstore(V)),
        -    B = zeros(eltype(V.basis1p), _maxstore(V)),
        -    A = alloc_B(V.basis1p),
        -    dA = alloc_dB(V.basis1p)
        -     )
        - 
        - 
        - function evaluate_d!(dEs, tmpd, V::TreePIPot{T}, Rs, Zs, z0) where {T}
        -    iz0 = z2i(V, z0)
        -    AA = tmpd.AA
        -    B = tmpd.B
        -    tmpd_basis1p = tmpd.tmpd_basis1p
        -    basis1p = V.basis1p
        -    tree = V.trees[iz0]
        -    nodes = tree.nodes
        -    coeffs = tree.coeffs
        - 
        -    fill!(B, 0)
        - 
        -    # FORWARD PASS
        -    # ------------
        -    # evaluate the 1-particle basis
        -    # this puts the first `tree.num1` 1-b (trivial) correlations into the
        -    # storage array, and from these we can build the rest
        -    evaluate!(AA, tmpd_basis1p, basis1p, Rs, Zs, z0)
        - 
        -    # Stage 2 of evaluate!
        -    # go through the tree and store the intermediate results we need
        -    # @inbounds @fastmath
        -    for i = (tree.num1+1):tree.numstore
        -       t = nodes[i]
        -       a = AA[t[1]] * AA[t[2]]
        -       AA[i] = a
        -    end
        - 
        -    # BACKWARD PASS
        -    # --------------
        -    # fill the B array -> coefficients of the derivatives
        -    for i = length(tree):-1:(tree.num1+1)
        -       c = coeffs[i]
        -       n1, n2 = nodes[i]
        -       B[n1] = muladd(c, AA[n2], B[n1])
        -       B[n2] = muladd(c, AA[n1], B[n2])
        -    end
        - 
        -    # stage 3: get the gradients
        -    fill!(dEs, zero(JVec{T}))
        -    Araw = tmpd.A
        -    dAraw = tmpd.dA
        -    for (iR, (R, Z)) in enumerate(zip(Rs, Zs))
        -       dA = evaluate_d!(Araw, dAraw, tmpd_basis1p, basis1p, R, Z, z0)
        -       iz = z2i(basis1p, Z)
        -       B_z = @view B[basis1p.Aindices[iz, iz0]]
        -       for iA = 1:length(dA)
        -          dEs[iR] += real(B_z[iA] * dA[iA])
        -       end
        -    end
        - 
        -    return dEs
        - end
        - 
        - 
        - 
        - end
        - 
