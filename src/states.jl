

export EuclideanVectorState, DiscreteState, ACEConfig

@doc raw"""
`struct EuclideanVectorState` : a $\mathbb{R}^3$-vector, which transforms under
the rotation group as
```math
g_Q \cdot {\bm r} = Q {\bm r}.
```
It typically defines a position or a force.
"""
abstract type EuclideanVectorState{T} <: AbstractContinuousState end


struct PositionState{T} <: EuclideanVectorState{T} 
   rr::SVector{3, T}
end

# All this could be generated by a macro ??
# >>>>>>
label(X::PositionState) = "ùíì"
_val(X::PositionState) = X.rr


# Base.length(X::EuclideanVectorState) = 3   # really? should this be 1??

PositionState{T}(p::NamedTuple) where {T} = PositionState(p) 
PositionState(p::NamedTuple) = PositionState(; p...)
PositionState(T1 = Float64; rr::SVector{3, T} = zero(SVector{3, T1}))  where {T} =  
      PositionState(rr)

Base.zero(::Union{TX, Type{TX}}) where {TX <: PositionState{T}} where {T} = PositionState(T)

Base.promote_rule(::Type{T}, ::Type{PositionState{S}}) where {T <: Number, S <: Number} = 
      PositionState{promote_type(T, S)}

Base.promote_rule(::Type{PositionState{T}}, ::Type{PositionState{S}}) where {T <: Number, S <: Number} = 
      PositionState{promote_type(T, S)}

# <<<<<<


Base.show(io::IO, X::EuclideanVectorState) = print(io, "$(label(X))$(_val(X))")

import LinearAlgebra: norm
import Base: *, -, +, isapprox, rtoldefault, real
*(A::Union{Number, AbstractMatrix}, X::TX) where {TX <: EuclideanVectorState} =
      TX(A * _val(X))
*(X::EuclideanVectorState, a::Number) =
      promote_type(typeof(X), typeof(a))(a * _val(X))
-(X::TX) where {TX <: EuclideanVectorState} = TX( - _val(X) )
-(X1::EuclideanVectorState, X2::EuclideanVectorState) = 
      promote_type(typeof(X1), typeof(X2))(_val(X1) - _val(X2))
+(X1::T1, X2::T2) where {T1 <: EuclideanVectorState, T2 <: EuclideanVectorState} = 
      promote_type(T1, T2)(_val(X1) + _val(X2))
+(X1::T, u::SVector{3}) where {T <: EuclideanVectorState} = T(_val(X1) + u)
isapprox(X1::EuclideanVectorState, X2::EuclideanVectorState) = 
      isapprox(_val(X1), _val(X2))
rtoldefault(::Union{T, Type{T}}, ::Union{T, Type{T}}, ::Real) where {T <: EuclideanVectorState{S}} where {S} = 
      rtoldefault(real(S))
norm(X::EuclideanVectorState) = norm(_val(X))

real(X::PositionState{T}) where {T} = PositionState{real(T)}(real.(_val(X)))

# NOT REALLY NEEDED RIGHT NOW?!?!?
# @doc raw"""
# `struct DiscreteState` : a state ``\mu`` specified by a discrete number of
# possible values, e.g. ranging through ``\mathbb{Z}`` or ``\mathbb{Z}_p``.
# Discrete states cannot possibly have a non-trivial transformation under
# a continuoue group action, hence it is assumed to be invariant, i.e.,
# ```math
# g_Q \cdot \mu = \mu
# ```
# """
# struct DiscreteState{T, SYM} <: AbstractDiscreteState
#    val::T
#    _valsym::Val{SYM}
# end

# DiscreteState(sym::Symbol) = DiscreteState(0, Val(sym))
# DiscreteState{T, SYM}(val::T) where {T, SYM} = DiscreteState(val, Val{SYM}())

# Base.show(io::IO, s::DiscreteState{T, SYM}) where {T, SYM} =
#          print(io, "$(SYM)[$(s.val)]")

# Base.getproperty(s::DiscreteState{T, SYM}, sym) where {T, SYM} =
#       sym == SYM ? getfield(s, :val) : getfield(s, sym)




struct ACEConfig{STT} <: AbstractConfiguration
   Xs::Vector{STT}   # list of states
end

# --- iterator to go through all states in an abstract configuration assuming
#     that the states are stored in cfg.Xs

Base.iterate(cfg::AbstractConfiguration) =
   length(cfg.Xs) == 0 ? nothing : (cfg.Xs[1], 1)

Base.iterate(cfg::AbstractConfiguration, i::Integer) =
   length(cfg.Xs) == i ? nothing : (cfg.Xs[i+1], i+1)

Base.length(cfg::AbstractConfiguration) = length(cfg.Xs)

Base.eltype(cfg::AbstractConfiguration) = eltype(cfg.Xs)