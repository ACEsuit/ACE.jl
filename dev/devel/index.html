<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer Docs · ACE.jl Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">ACE.jl Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../math/">Math</a></li><li class="is-active"><a class="tocitem" href>Developer Docs</a><ul class="internal"><li><a class="tocitem" href="#Summary-of-types-and-type-hierarchy"><span>Summary of types and type hierarchy</span></a></li><li><a class="tocitem" href="#States-and-Configurations-(Inputs)"><span>States and Configurations (Inputs)</span></a></li><li><a class="tocitem" href="#One-Particle-Basis"><span>One Particle Basis</span></a></li><li><a class="tocitem" href="#Permutation-Invariant-Basis"><span>Permutation-Invariant Basis</span></a></li><li><a class="tocitem" href="#Properties-and-symmetries"><span>Properties and symmetries</span></a></li><li><a class="tocitem" href="#The-symmetric-basis"><span>The symmetric basis</span></a></li><li><a class="tocitem" href="#Linear-ACE-Model"><span>Linear ACE Model</span></a></li><li><a class="tocitem" href="#Evaluators"><span>Evaluators</span></a></li></ul></li><li><a class="tocitem" href="../docs/">Types &amp; Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developer Docs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer Docs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ACEsuit/ACE.jl/blob/master/docs/src/devel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-Documentation-/-Internals"><a class="docs-heading-anchor" href="#Developer-Documentation-/-Internals">Developer Documentation / Internals</a><a id="Developer-Documentation-/-Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Documentation-/-Internals" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">WARNING</header><div class="admonition-body"><p>This documentation is very much a work in progress since the general framework for ACE.jl has only slowly been developing. There are likely leftovers from earlier version. That said, the framework is now slowly establishing itself, and documentation will now get updated and improved over time. Please <a href="https://github.com/ACEsuit/ACE.jl/issues">file issues</a>, <a href="https://github.com/ACEsuit/ACE.jl/discussions">ask questions</a> or make PRs. </p></div></div><h2 id="Summary-of-types-and-type-hierarchy"><a class="docs-heading-anchor" href="#Summary-of-types-and-type-hierarchy">Summary of types and type hierarchy</a><a id="Summary-of-types-and-type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-types-and-type-hierarchy" title="Permalink"></a></h2><p>The <code>ACE.jl</code> package heavily utilizes composition (as opposed to inheritance), which is well aligned with Julia&#39;s type system and recommended style. Basis sets and calculators are built from the following base types.</p><ul><li><code>OneParticleBasis</code> : abstract supertype of a 1-particle basis</li><li><a href="../docs/#ACE.PIBasis"><code>PIBasis</code></a> : concrete implementation of a permutation-invariant basis, employing a <code>OneParticleBasis</code> and a specification of all possible correlations</li><li><a href="../docs/#ACE.SymmetricBasis"><code>SymmetricBasis</code></a> : implementation of the &quot;coupling&quot; to achieve additional symmetries, e.g. O(3)</li><li><a href="../docs/#ACE.LinearACEModel"><code>LinearACEModel</code></a> : representation of one or more properties in terms of a basis.</li></ul><h2 id="States-and-Configurations-(Inputs)"><a class="docs-heading-anchor" href="#States-and-Configurations-(Inputs)">States and Configurations (Inputs)</a><a id="States-and-Configurations-(Inputs)-1"></a><a class="docs-heading-anchor-permalink" href="#States-and-Configurations-(Inputs)" title="Permalink"></a></h2><h3 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h3><p>Each particle is described by one or more variables, including e.g. its position, species, spin, charge, etc. The input space <span>$\mathbb{X}$</span> is simply the space in which those variables reside. The input variable must be a subtype <code>AbstractState</code> following some strict conventions.</p><p>In practise one would most likely use the <code>State</code> type which simply wraps a <code>NamedTuple</code>. E.g. if we wanted a particle that only has a position we could define this as </p><pre><code class="language-julia hljs">X = State(rr = rand(SVector{3, Float64}))</code></pre><p>If we have a particle that has position <code>rr</code> and species <code>Z</code> attributes, and maybe an invariant feature <code>u</code>, then we would define this as </p><pre><code class="language-julia hljs">X = State(rr = rand(SVector{3, Float64}), Z = 13, u = rand())</code></pre><p>The data can be accessed via <code>.</code> or <code>getproperty</code>.</p><p>It is crucial that the attributes/features <code>rr, Z, u</code> are known to the one-particle basis, i.e. when evaluating <span>$\phi_v(X)$</span> the one-particle basis <span>$\phi_v$</span> must &quot;know&quot; that it can obtain the position by calling <code>X.rr</code>; more on this below. </p><h3 id="Configurations"><a class="docs-heading-anchor" href="#Configurations">Configurations</a><a id="Configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Configurations" title="Permalink"></a></h3><p>A collection of <em>states</em> is a configuration. The supertype for configurations is <code>AbstractACEConfiguration</code>. The simples concrete implementatin is <code>ACEConfiguration</code> which simply wraps a <code>Vector{&lt;: AbstractState}</code>. Configurations must be iterable. Example: </p><pre><code class="language-julia hljs">cfg = ACEConfig( [ State(rr = randn(SVector{3, Float64})) for _=1:10 ])</code></pre><p>creates a configuration containing 10 particles having only a position as an attribute.</p><h3 id="DStates"><a class="docs-heading-anchor" href="#DStates">DStates</a><a id="DStates-1"></a><a class="docs-heading-anchor-permalink" href="#DStates" title="Permalink"></a></h3><p>While a <code>State</code> is just a description of an object, a <code>DState</code> can be thought of as an element of a vector space which we can manipulate. A classical analogy is that a <code>State</code> might be a point while a <code>DState</code> a vector pointing to it. E.g. we can add two <code>DState</code>s or multipy them with a scalar. This is not allowed for a <code>State</code>. This places certain restrictions on what a <code>DState</code> might contain. </p><p>The main application of this in ACE.jl is that <code>DState</code>s are derivatives of <code>State</code>s. </p><p><strong>TODO:</strong> write a more thorough explanation and how they are used and constructed. </p><h2 id="One-Particle-Basis"><a class="docs-heading-anchor" href="#One-Particle-Basis">One Particle Basis</a><a id="One-Particle-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#One-Particle-Basis" title="Permalink"></a></h2><p>The one-particle basis is arguably the most important object in defining an ACE model. It is the fundamental building block for reprenting an input, before the generic methods/algorithms for correlatons and symmetrisation take over.</p><p>A one-particle basis is a basis of functions <span>$\phi_v : \mathbb{X} \to \mathbb{C}$</span> (or, <span>$\mathbb{R}$</span>) defined through a subtype of</p><pre><code class="language-julia hljs">abstract type OneParticleBasis end</code></pre><p>Concrete subtypes must implement the projection of the atom density onto the one-particle basis, </p><p class="math-container">\[  A_{v}( \{ X_j \}_{j} ) = \sum_{j} \phi_v(X_j).\]</p><p>This is done with the following interface:</p><pre><code class="language-julia hljs">A = ...      # allocate storage for A = [ A_z for iz=1:NZ ]
evaluate!(A, basis1p, cfg)    # fill A = [ A_z for iz=1:NZ ]</code></pre><p>In practise this would more conveniently be called via</p><pre><code class="language-julia hljs">A = evaluate(basis1p, cfg)</code></pre><p>with the allocation occuring behind the scenes. Normally, <code>basis1p</code> will have an object pool implemented, then the array <code>A</code> when no longer needed can be returned to the pool via </p><pre><code class="language-julia hljs">release_B!(basis1p, A)</code></pre><p>For example when 1p-basis evaluate occurs as part of the full ACE model, then all allocations occur at a suitable point in the evaluation chain. The user need not be concerned about this. </p><p>There is a lot of code duplication in the implementation of <code>OneParticleBasis</code>, which we can avoid by a generic implementation of <code>evaluate!</code> which loops through all <code>X in Xs</code> and then calls</p><pre><code class="language-julia hljs">add_into_A!(A, basis1p, X)
# should be equivalent to A[:] += evaluate(basis1p, X)</code></pre><p>an implementation of <code>OneParticleBasis</code> then only needs to overload <code>add_into_A!</code> which evaluates all <span>$\phi_v$</span> at one state pair <code>X</code> and adds the basis values into a pre-allocated vector <code>A</code>.</p><p>Although in most cases AD and backpropagation will be used to take gradients, for performance reasons it is important to have hand-coded gradients for the 1p-basis implementations. For the gradients w.r.t. a single state the following must be provided:</p><pre><code class="language-julia hljs">dPhi =  .....                     # storage for (∇ϕ_k)_k
evaluate_d!(dPhi, basis1p, X)     # fill dPhi with (∇ϕ_k)_k</code></pre><p>The interface does not require <code>evaluate_d!(dPhi, basis1p, cfg)</code>, which is done behind the scenes (see <code>oneparticlebasis.jl</code>). </p><h3 id="Basis-Indexing"><a class="docs-heading-anchor" href="#Basis-Indexing">Basis Indexing</a><a id="Basis-Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Indexing" title="Permalink"></a></h3><p>To build a <code>PIBasis</code> (see below) the <code>OneParticleBasis</code> musts also provide methods that specify it:</p><pre><code class="nohighlight hljs">get_spec(basis, i::Integer)   # specification of the ith basis function
get_spec(basis)               # vector containing all basis function specs</code></pre><p>A basis function is specified as a <code>NamedTuple</code>. For instance, in the above example the values of the <span>$\mu, n, l, m$</span> indices would specify <span>$\phi_{\mu n l m}$</span>. Thus the basis function is specified by</p><pre><code class="language-julia hljs">   b = (μ = ..., n = ..., l = ..., m = ...)</code></pre><p>This framework is particularly useful if some tuples overlap across different components of a product one-particle basis. For example, if <span>$R_n$</span> depends also on the species, or if the radial basis is given as <span>$R_{nl}$</span>.</p><p>To let the generic code know which indices are available and what the range of each index is the one-particle basis must implement <code>symbols</code> and <code>indexrange</code>.</p><h3 id="Notes"><a class="docs-heading-anchor" href="#Notes">Notes</a><a id="Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Notes" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Bonds vs Sites</header><div class="admonition-body"><p>The theory allows some extensions that are currently only accessible through an ad hoc &quot;hack&quot;, but which may turn out to be the best strategy to implement them anyhow: The most important case is that when modelling e.g. an atomic environment, the one-particle basis may also depend on the center-atom, which could be written as    <code>math       A_v = \sum_{j} \phi_v(X_j, X_i).</code>   This is not directly supported. Instead one should simply identify a state <span>$X_j$</span> with the state of the bond <span>$(X_i, X_j)$</span> and include the attributes of the center-atom in <span>$X_j$</span>. For example, if <span>$\phi_v$</span> depends also on the species of atoms <span>$i, j$</span>, this might take the form    <code>julia       X_j = State(rr = position[j] - position[i], Z = Z[j], Z0 = Z[i])</code></p></div></div><div class="admonition is-info"><header class="admonition-header">TODO - vectorisation</header><div class="admonition-body"><p>It could be worth enabling the possibility to overload <code>evaluate_d!(dPhi, basis1p, cfg)</code> for faster evaluation, e.g. AVX, GPU acceleration. This hasn&#39;t been explored at all yet. </p></div></div><div class="admonition is-warning"><header class="admonition-header">WARNING</header><div class="admonition-body"><p>The gradient interface is not really done yet and may need more design work! The issue remaining is to decide how to manage the situation that gradient with only specific attributes of a state might be required but not w.r.t. the entire state. This is the main open problem in the current redesign of ACE.jl </p></div></div><h3 id="Product-1p-Basis"><a class="docs-heading-anchor" href="#Product-1p-Basis">Product 1p-Basis</a><a id="Product-1p-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Product-1p-Basis" title="Permalink"></a></h3><p>The most common situation is that <code>basis1p</code> is a product of basis functions acting on different variables. This can be constructed using <code>Product1pBasis</code>. For example, a one-particle basis of the kind</p><p class="math-container">\[   \phi_{\mu n l m}(X) = \delta(\mu_X - \mu) R_n(r_X) Y_l^m({\bm r}_X)\]</p><p>can be constructed as</p><pre><code class="language-julia hljs">Bμ = Species1PBasis(species)
Rn = Rn1pBasis(ACE.Utils.radial_basis())
Ylm = Ylm1pBasis(10)
basis1p = Product1pBasis( (Bμ, Rn, Ylm) )</code></pre><p>Components from which to build a <code>Product1pBasis</code> are listed below.</p><h3 id="Concrete-Implementations-of-One-particle-Bases"><a class="docs-heading-anchor" href="#Concrete-Implementations-of-One-particle-Bases">Concrete Implementations of One-particle Bases</a><a id="Concrete-Implementations-of-One-particle-Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-Implementations-of-One-particle-Bases" title="Permalink"></a></h3><ul><li><a href="../docs/#ACE.Rn1pBasis"><code>Rn1pBasis</code></a> : radial basis of type <span>$R_n(r)$</span> wrapping an orthogonal polynomial basis in transformed coordinates. </li><li><a href="../docs/#ACE.Ylm1pBasis"><code>Ylm1pBasis</code></a> : wrapping complex spherical harmonics </li><li><a href="../docs/#ACE.Scal1pBasis"><code>Scal1pBasis</code></a> : a generic scalar 1p basis component. It differs from <code>Rn1pBasis</code> in that it takes a scalar as input while <code>Rn1pBasis</code> takes a vector and transforms it to a scalar via <code>norm</code>. In hindsight, these two codes should probably be compined streamlined into a single one.</li><li><code>ACEatoms.jl</code> provides also a species-1p-basis; see docs for ACEatoms.jl</li><li>wip: discrete, one-hot, Fourier, other symmetries</li></ul><h2 id="Permutation-Invariant-Basis"><a class="docs-heading-anchor" href="#Permutation-Invariant-Basis">Permutation-Invariant Basis</a><a id="Permutation-Invariant-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Permutation-Invariant-Basis" title="Permalink"></a></h2><p>The permutation-invariant basis is a <em>concrete</em> type</p><pre><code class="language-julia hljs">struct PIBasis end</code></pre><p>which implements the <span>$N$</span>-correlations which can be thought of as  tensor-product like basis functions</p><p class="math-container">\[   {\bm A}_{\bm v}
   =
   \prod_{t = 1}^N A_{v_t}
   \qquad \text{where} \quad
   {\bm v} \in \mathbb{N}^N\]</p><p>The (naive) interface for this is as follows:</p><pre><code class="language-julia hljs">evaluate!(AA, pibasis, cfg)
evaluate_ed!(AA, dAA, pibasis, cfg)</code></pre><p>where the storage arrays are</p><ul><li><code>AA::Vector{&lt;: Number}</code> : to store any AA_kk^{zz, z0} with z0 fixed, i.e. the AA vector for a single site only. To use a PIBasis as the <em>actual</em> basis rather than an auxiliary one should wrap it (see bonds – TODO!)</li><li><code>dAA::Matrix{&lt;: ??}</code> with dimension basis-length x number of particles, the <code>eltype</code> is specified by what the derivatives of the states are. E.g. if the states are described by a <code>State</code> then <code>dAA::Matrix{&lt;: DState}</code></li></ul><p>There are two implementations for evaluating the a <code>PIBasis</code>, one based on explicitly going through the loop <span>$\prod_t$</span>, the other on a recursive evaluation via a DAG (currently disabled). TODO: need to re-enable this, and add references.</p><h3 id="Generating-a-OneParticleBasis-and-PIBasis,-and-BasisSelectors"><a class="docs-heading-anchor" href="#Generating-a-OneParticleBasis-and-PIBasis,-and-BasisSelectors">Generating a <code>OneParticleBasis</code> and <code>PIBasis</code>, and <code>BasisSelector</code>s</a><a id="Generating-a-OneParticleBasis-and-PIBasis,-and-BasisSelectors-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-a-OneParticleBasis-and-PIBasis,-and-BasisSelectors" title="Permalink"></a></h3><p>A 1p basis function is defined by a <code>NamedTuple</code>. For example, for an <span>$R_n Y_l^m$</span> basis or an <span>$R_{nl} Y_l^m$</span> basis a 1p basis function would be specified (e.g.) by a tuple </p><pre><code class="language-julia hljs">     (n = 3, l = 2, m = -1)</code></pre><p>where <code>3, 2, -1</code> just stand for possible values for the basis indices <code>n, l, m</code>. Of course we could define the basis indices to be calles <code>nr, lr, mr</code> and then the tuple would be <code>(nr = 3, lr = 2, mr = -1)</code>. </p><p>Creating a 1p basis requires generating the list of all tuples specifying the 1p basis functions. This occurs in <a href="../docs/#ACE.init1pspec!"><code>init1pspec!</code></a>, called via </p><pre><code class="language-julia hljs">init1pspec!(B1p, Bsel)</code></pre><p>where <code>B1p</code> is the 1p basis and <code>Bsel</code> a basis selector which specifies which of the tuples will be part of the basis specification. </p><p>A pi basis function (product basis function) is specified via a vector of NamedTuples. The the specification is gives as a list of such vectors of namedtuples and is normally generated via <code>gensparse</code>. <code>gensparse</code> uses implicitly uses again a basis selector to determine which basis functions to keep. </p><h3 id="Basis-Selectors"><a class="docs-heading-anchor" href="#Basis-Selectors">Basis Selectors</a><a id="Basis-Selectors-1"></a><a class="docs-heading-anchor-permalink" href="#Basis-Selectors" title="Permalink"></a></h3><p>A basis selector <code>Bsel</code> must specify: </p><ul><li><code>degree</code> : several methods to assign a degree to a basis function; this is required since in some places we need an ordering the 1p basis functions </li><li><code>isadmissible</code> : decide whether a basis function is part of the basis or not </li><li><code>maxorder</code> : the larged correlation-order to be generated in the basis</li></ul><p>For example <a href="../docs/#ACE.SimpleSparseBasis"><code>SimpleSparseBasis</code></a> is implemented as follows (sketch)</p><pre><code class="language-julia hljs">struct SimpleSparseBasis &lt;: DownsetBasisSelector
   maxorder::Int
   maxdeg::Float64
end</code></pre><p>The <code>degree</code> of a 1p basis function is specified by the 1p basis itself. Next, <code>isadmissible</code> is defined as <code>isadmissible = degree &lt;= maxdeg</code>. And <code>maxorder</code> is simply a user-defined parameter. </p><p>But arbitrarily complex basis selectors could be implemented as long as they specify downsets in the lattice of all possible basis functions. </p><p>A very useful implementation is the <a href="../docs/#ACE.SparseBasis"><code>SparseBasis</code></a> which allows giving different weights to the different basis indices, e.g., one might want to give <code>l</code> a higher weight than <code>n</code> if one believes that fewer angular basis functions than radial basis functions are required. Another idea is to use difference degrees for different correlation orders, or rather than a total degree one could use different kinds of norms in the basis function lattice.</p><h2 id="Properties-and-symmetries"><a class="docs-heading-anchor" href="#Properties-and-symmetries">Properties and symmetries</a><a id="Properties-and-symmetries-1"></a><a class="docs-heading-anchor-permalink" href="#Properties-and-symmetries" title="Permalink"></a></h2><p>A property <span>$\varphi$</span> is the output of an ACE model. Each property has certain symmetries attached to it. For example, an invariant <span>$\varphi$</span> satisfies</p><p class="math-container">\[   \varphi \circ Q = \varphi\]</p><p>A covariant Euclidean vector <span>$\varphi \in \mathbb{R}^3$</span> satisfies</p><p class="math-container">\[   \varphi \circ Q = Q \varphi.\]</p><p>An equi-variant spherical vector <span>$\varphi$</span> satisfies,</p><p class="math-container">\[   \varphi \circ Q = D(Q) \varphi.\]</p><p>and there are many more options as we move to higher-order tensors.</p><p>To model these symmetries we introduce the <code>SymmetricBasis</code> in the next section. To generate it a property must specify what its symmetries are.</p><p>All properties must be subtypes of <code>AbstractProperty</code>. For example</p><p class="math-container">\[struct Invariant{T} &lt;: AbstractProperty
   val::T
end\]</p><p>The actual value(s) should always be encoded in the field <code>val</code> since this allows for generic implementation of several methods required for properties, such as arithmetic operations.</p><div class="admonition is-info"><header class="admonition-header">TODO</header><div class="admonition-body"><p>discuss the interface how the properties specify their symmetry. For the    moment this can be looked up in <code>properties.jl</code>. It is done through the    initial condition for the coupling coefficient recursion.</p></div></div><h2 id="The-symmetric-basis"><a class="docs-heading-anchor" href="#The-symmetric-basis">The symmetric basis</a><a id="The-symmetric-basis-1"></a><a class="docs-heading-anchor-permalink" href="#The-symmetric-basis" title="Permalink"></a></h2><p>A key aspect of <code>ACE.jl</code> is to treat permutation symmetry <em>AND</em> additional possibly continuous symmetries, O(3) being the main prototype. Other symmetries are WIP, in particular general <span>$O(d)$</span> and  <span>$O(d1, d2)$</span>, but we plan to also provide <span>$U(n)$</span> and maybe others. </p><p>Given a property <span>$\varphi$</span> which has certain symmetries attached to it we want to generate a basis <span>$\mathbf{B}$</span> which respects these symmetries as well. In <code>ACE.jl</code> this is provided by the <code>SymmetricBasis</code> type, which transforms from the density correlation basis <span>$\mathbf{A}$</span> to a symmetry adapted variant by computing all possible couplings of the spherical harmonics that produce the desired symmetry.</p><p class="math-container">\[ {\bm B} = \mathcal{U} \cdot {\bm A}.\]</p><p>Note this relies on a specific choice of the one-particle basis; see references. The implementation of the <span>$\mathcal{U}$</span> coefficients in <code>rotations3d.jl</code> and <code>symmetrygroups.jl</code> is based on several numerical SVDs performed in small blocks. </p><p>The <code>RPIBasis</code> type stores only two fields: the <code>PIBasis</code> and the coefficients <span>$C$</span>.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ul><li><code>Invariant</code> : <span>$\varphi \circ Q = \varphi$</span> </li><li><code>EuclideanVector</code> : <span>$\varphi \circ Q = Q \varphi$</span></li><li><code>EuclideanMatrix</code> (wip) : <span>$\varphi \circ Q = Q \varphi Q^T$</span> </li><li><code>SphericalVector</code> : <span>$\varphi \circ Q = D(Q) \varphi$</span></li><li><code>SphericalMatrix</code> : <span>$\varphi \circ Q = D(Q) \varphi D(Q)^T$</span> </li></ul><h3 id="Specifying-the-symmetry-on-the-1-particle-basis"><a class="docs-heading-anchor" href="#Specifying-the-symmetry-on-the-1-particle-basis">Specifying the symmetry on the 1-particle basis</a><a id="Specifying-the-symmetry-on-the-1-particle-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Specifying-the-symmetry-on-the-1-particle-basis" title="Permalink"></a></h3><p>TODO : insert details. </p><p>At the moment this is done manually by specifying exactly what the symmetry group is and what basis indices it is acting on. This is all very much in prototype stages and there are likely more elegant ways to implement this. For details see <code>symmetrygroups.jl</code> and <code>test_multish.jl</code>. But just to give a taster: </p><pre><code class="language-julia hljs"># standard / default: 
B1p = ACE.Utils.RnYlm_1pbasis(; maxdeg=maxdeg, D = D, )
basis = SymmetricBasis(φ, B1p, O3(), ord, maxdeg; Deg = D)
# Ylm with different indices 
B1p_r = ACE.Utils.RnYlm_1pbasis(; maxdeg=maxdeg, D = D, 
                                   varsym = :rr, idxsyms = (:nr, :lr, :mr))
basis_r = SymmetricBasis(φ, B1p_r, O3(:lr, :mr), ord, maxdeg; Deg = D)
# Magnetism without spin-orbit coupling 
B1p_r = ACE.Utils.RnYlm_1pbasis(; maxdeg=maxdeg, D = D, 
                                   varsym = :rr, idxsyms = (:nr, :lr, :mr))
B1p_s = ACE.Ylm1pBasis(maxdeg; varsym = :ss, lsym = :ls, msym = :ms)
basis = SymmetricBasis(φ, B1p_r * B1p_s, O3(:lr, :mr) ⊗ O3(:ls, :ms), ord, maxdeg; Deg = D)</code></pre><h2 id="Linear-ACE-Model"><a class="docs-heading-anchor" href="#Linear-ACE-Model">Linear ACE Model</a><a id="Linear-ACE-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-ACE-Model" title="Permalink"></a></h2><p>A basis can be used to define a linear ACE model (and linear ACE models can then be composed to make up nonlinear ACE models, this will be discussed elsewhere.).  In <code>ACE.jl</code> this is achieved as follows: after constructing a <code>basis::SymmetricBasis</code> following the instructions above, one then has to supply a coefficient vector <code>c</code>. Then a linear ACE model is obtained by calling </p><pre><code class="language-julia hljs">model = LinearACEModel(basis, c)</code></pre><p>An important comment is that one can also produce multiple properties with a single basis but different coefficients. See the docstring for <a href="../docs/#ACE.LinearACEModel"><code>LinearACEModel</code></a> for more details. </p><p>An ACE model can be evaluated as follows: </p><ul><li><code>evaluate(model, cfg)</code></li><li><code>grad_config(model, cfg)</code> : gradient w.r.t. configurations (e.g. forces)</li><li><code>grad_params(model, cfg)</code> : gradient w.r.t. parameters</li></ul><p>We are also in the process of completing <code>rrules</code> for the linear ACE model so that it can be composed or incorporated into a loss and then automatically differentiated. A good place to explore how to work with <code>LinearACEModel</code> are <code>test_linearmodel.jl</code> and <code>test_multiprop.jl</code>.</p><h2 id="Evaluators"><a class="docs-heading-anchor" href="#Evaluators">Evaluators</a><a id="Evaluators-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluators" title="Permalink"></a></h2><p>TODO </p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../math/">« Math</a><a class="docs-footer-nextpage" href="../docs/">Types &amp; Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Monday 23 August 2021 02:40">Monday 23 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
