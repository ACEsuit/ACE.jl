<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Products of Polynomials · ACE.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">ACE.jl Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><a class="tocitem" href="../gettingstarted/">Getting Started</a></li><li><a class="tocitem" href="../devel/">Developer Docs</a></li><li><a class="tocitem" href="../envpairbasis/">ED-Bonds</a></li><li><span class="tocitem">Pure ACE</span><ul><li><a class="tocitem" href="../pureintro/">What is Pure ACE</a></li><li><a class="tocitem" href="../purerecursion/">Pure Basis Recursion</a></li><li class="is-active"><a class="tocitem" href>Products of Polynomials</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Pure ACE</a></li><li class="is-active"><a href>Products of Polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Products of Polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ACEsuit/ACE.jl/blob/master/docs/src/polyproducts.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h3 id="Products-of-Polynomials"><a class="docs-heading-anchor" href="#Products-of-Polynomials">Products of Polynomials</a><a id="Products-of-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Products-of-Polynomials" title="Permalink"></a></h3><h3 id="Products-of-Radial-Polynomials"><a class="docs-heading-anchor" href="#Products-of-Radial-Polynomials">Products of Radial Polynomials</a><a id="Products-of-Radial-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Products-of-Radial-Polynomials" title="Permalink"></a></h3><p>Suppose we have a basis of orthonormal radial polynomials</p><p class="math-container">\[ (J_n, J_{n&#39;})_w = \delta_{n,n&#39;}\]</p><p>where <span>$(\cdot, \cdot)_w$</span> is any inner product we choose. Product <span>$J_{n_1} J_{n_2}$</span> are again polynomials and can therefore be expanded in terms of the basis <span>$J_\nu$</span>, i.e.,</p><p class="math-container">\[   J_{n_1} J_{n_2} = \sum_\nu P_{n_1, n_2}^\nu J_\nu.\]</p><p>Because they are orthonormal, the expansion coefficients are simply given by</p><p class="math-container">\[   P_{n_1, n_2}^\nu = ( J_{n_1} J_{n_2}, J_\nu)_w.\]</p><h4 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h4><p>The radial polynomial products are implemented in `src/polynomials/products.jl&#39; in a lazy datastructure.</p><pre><code class="language-julia">struct OrthPolyProdCoeffs</code></pre><p>If <code>prodcoeffs::OrthPolyProdCoeffs</code> then calling</p><pre><code class="language-julia">P = prodcoeffs(n1, n2)</code></pre><p>returns a vector <code>P</code> such that <code>P[nu]</code> is the value of <span>$P^{n_1,n_2}_\nu$</span>, allowing indices <span>$\nu \in \mathbb{Z}$</span>. Coefficients outside the actual range will simply be zero. The coefficient vectors are computed lazyly, i.e., will only be precomputed when required but then stored for later use.</p><p>The precomputation is done by explicit evaluation of the inner products as described above.</p><p>Alternatively we can access <span>$P_{n_1 n_2}^\nu$</span> with an iterator</p><pre><code class="language-none">for (nu, Pnu) in coeffs(n1, n2)
   # ...
end</code></pre><p>will iterate only over the non-zero coefficients.</p><h3 id="The-case-of-Chebyshev-Polynomials-(TODO)"><a class="docs-heading-anchor" href="#The-case-of-Chebyshev-Polynomials-(TODO)">The case of Chebyshev Polynomials (TODO)</a><a id="The-case-of-Chebyshev-Polynomials-(TODO)-1"></a><a class="docs-heading-anchor-permalink" href="#The-case-of-Chebyshev-Polynomials-(TODO)" title="Permalink"></a></h3><p>The simplest case is that of monomials <span>$J_n = x^n (x - x_l)^{p_l} (x - x_r)^{p_r)$</span>. The product <span>$J_{n_1} J_{n_2}$</span> can then by written with just five non-zero coefficients <span>$P_{n_1 n_2}^{N}$</span>. But monomials lead to sever numerical instabilities.</p><p>The &quot;next-best&quot; option in terms of sparsity of the product coefficients appear to be Chebyshev polynomials.</p><p class="math-container">\[   2 T_{m}(x) T_n(x) = T_{m+n}(x) + T_{|m-n|}(x)\]</p><p>That is if we choose</p><p class="math-container">\[   J_n = T_{n+1} f_{\rm cut}\]</p><p>then</p><p class="math-container">\[   J_{n_1} J_{n_2} = T_{n_1+1} T_{n_2+1} f_{\rm cut} f_{\rm cut}.\]</p><p>For <span>$N_p = p_l + p_r$</span> we have</p><p class="math-container">\[   f_{\rm cut} = \sum_{n = 0}^{N_p} T_n,\]</p><p>hence</p><p class="math-container">\[\begin{aligned}
   J_{n_1} J_{n_2}
   &amp;=
   \sum_{n = 0}^{N_p} T_{n_1+1} T_{n_2+1} T_n f_{\rm cut} \\
   &amp;=
   \frac{1}{2} \sum_{n = 0}^{N_p} \big( T_{n+1+n_2+2} + T_{|n_1-n_2|} \big) T_n f_{\rm cut}  \\
   &amp;=
   \frac{1}{2} \sum_{n = 0}^{N_p} \Big(
           T_{n+1+n_2+2 + n} + T_{|n_1+n_2+2 - n|}
         + T_{|n_1-n_2| + n} + T_{| |n_1-n_2| - n |} \Big) f_{\rm cut}.
\end{aligned}\]</p><p>This means that there are at most <span>$4 (N_p + 1)$</span>. non-zero coefficients, independently of the chosen maximum degree.</p><p>In practise it is quite likely that this makes little difference. We normally choose <span>$p_l = p_r = 2$</span> which leads to approx. 20 non-zero coefficients. But this is already close to the maximum degree we allow, hence for a general basis we will see little gain. An interesting question, maybe, is whether numerical stability is improved for a Chebyshev basis because of the explicit analytic recursion.</p><h3 id="Products-of-spherical-harmonics"><a class="docs-heading-anchor" href="#Products-of-spherical-harmonics">Products of spherical harmonics</a><a id="Products-of-spherical-harmonics-1"></a><a class="docs-heading-anchor-permalink" href="#Products-of-spherical-harmonics" title="Permalink"></a></h3><p>A product of two spherical harmonics can again be expanded in terms of spherical harmonics,</p><p class="math-container">\[   Y_{l_1}^{m_1} Y_{l_2}^{m_2}
       = \sum_{\lambda, \mu} P_{l_1 m_1 l_2 m_2}^{\lambda \mu} Y_\lambda^\mu\]</p><p>where the &quot;coupling coefficients&quot; are given by</p><p class="math-container">\[   P_{l_1 m_1 l_2 m_2}^{\lambda \mu}
   =
   \sqrt{\frac{(2l_1+1)(2l_2+1)}{2\pi (2\lambda+1)} }
   C_{l_1 m_1 l_2 m_2}^{LM} C_{l_1 0 l_2 0}^{L0}\]</p><p>where <span>$C_{l_1 m_1 l_2 m_2}^{L,M}$</span> are the Clebsch-Gordan coefficients. These are non-zero only for</p><p class="math-container">\[\begin{aligned}
   &amp; |l_1 - l_2| \leq L \leq l_1 + l_2, \\
   &amp; M = m_1 + m_2, \\
   &amp; |M| \leq L, |m_i| \leq l_i, \\
   &amp; l_1 + l_2 - L \text{ is even.}\]</p><p>The first three of these conditions are the conditions for <span>$C_{l_1 m_1 l_2 m_2}^{LM}$</span> to be non-zero. The fourth condition follows from the fact that</p><p class="math-container">\[   C_{l_1 m_1 l_2 m_2}^{L M} =
   (-1)^{l_1 + l_2 - L} C_{l_1 (-m_1) l_2 (-m_2)}^{L (-M)}\]</p><p>and hence <span>$C_{l_1 0 l_2 0}^{L0}$</span> can only be non-zero if <span>$l_1 + l_2 - L$</span> is even.</p><p>These conditions ensure that the <span>$P_{l_1 m_1 l_2 m_2}^{L M}$</span> coefficients are extremely sparse. This is exploited when iterating over all required <span>$L, M$</span>.</p><h4 id="Implementation-2"><a class="docs-heading-anchor" href="#Implementation-2">Implementation</a><a class="docs-heading-anchor-permalink" href="#Implementation-2" title="Permalink"></a></h4><p>The coefficients <span>$P_{l_1 m_1 l_2 m_2}^{\lambda \mu}$</span> are implemented in the datastructure</p><pre><code class="language-julia">struct SHProdCoeffs</code></pre><p>To get the coefficients for a specific <code>l1, m1, l2, m2</code> we can call</p><pre><code class="language-julia">P = coeffs(l1, m1, l2, m2)</code></pre><p>where <code>coeffs::SHProdCoeffs</code>. To iterate over all non-zero coefficients,</p><pre><code class="language-julia">for (L, M, p) in P
   # ...
end</code></pre><h3 id="Products-of-one-particle-basis-function"><a class="docs-heading-anchor" href="#Products-of-one-particle-basis-function">Products of one-particle basis function</a><a id="Products-of-one-particle-basis-function-1"></a><a class="docs-heading-anchor-permalink" href="#Products-of-one-particle-basis-function" title="Permalink"></a></h3><p class="math-container">\[\begin{aligned}
   \phi_{n_1 l_1 m_1} \phi_{n_2 l_2 m_2}
   &amp;=
   R_{n_1} Y_{l_1}^{m_1} R_{n_2} Y_{l_2}^{m_2}  \\
   &amp;=
   \sum_N P_{n_1,n_2}^N R_N \sum_{L, M} P_{l_1m_1l_2m_2}^{LM} Y_{L}^M.
\end{aligned}\]</p><p>This means we have</p><p class="math-container">\[   \phi_{k_1} \phi_{k_2} =
   \sum_K P_{k_1 k_2}^K \phi_k\]</p><p>where <span>$k = (n, l, m)$</span> and</p><p class="math-container">\[   P_{k_1 k_2}^K = P_{n_1,n_2}^N P_{l_1m_1l_2m_2}^{LM}\]</p><p>The tensor product structure can be exploited in code if many such products have to be computed.</p><h3 id="Appendices"><a class="docs-heading-anchor" href="#Appendices">Appendices</a><a id="Appendices-1"></a><a class="docs-heading-anchor-permalink" href="#Appendices" title="Permalink"></a></h3><h4 id="Three-term-recurrance"><a class="docs-heading-anchor" href="#Three-term-recurrance">Three-term recurrance</a><a id="Three-term-recurrance-1"></a><a class="docs-heading-anchor-permalink" href="#Three-term-recurrance" title="Permalink"></a></h4><p>If the polynomials satisfy a three-term recurrance then there is an alternative way to obtain the product coefficients which does not require evaluating the inner products. This is currently not implemented, but we keep it here as a record for the future.</p><p>Suppose we have a radial polynomial basis satisfying the recursion</p><p class="math-container">\[\begin{aligned}
   J_1(x) &amp;= A_1 (x - x_l)^{p_l} (x - x_r)^{p_r} \\
   J_2 &amp;= (A_2 x + B_2) J_1(x) \\
   J_{n} &amp;= (A_n x + B_n) J_{n-1}(x) + C_n J_{n-2}(x)
\end{aligned}\]</p><p>For the save of brevity, we will write <span>$f_{\rm cut} := (x - x_l)^{p_l} (x - x_r)^{p_r}$</span>, o.e., <span>$J_1 = A_1 f_{\rm cut}$</span>. The functions <span>$J_n$</span> span the space of all polynomials that are multiples of <span>$f_{\rm cut}$</span>.</p><p>Since <span>$f_{\rm cut}$</span> divides all <span>$J_n$</span>, if we take a product <span>$p := J_{n}(x) J_{n&#39;}(x)$</span> then <span>$f_{\rm cut}$</span> also divides <span>$p$</span> and in particular <span>$p = q f_{\rm cut}$</span>. Since <span>$q$</span> is itself a polynomials it follows that</p><p class="math-container">\[ p = \sum_{\nu = 1}^{n+n&#39;+p_l + p_r} P^{n n&#39;}_\nu J_\nu\]</p><p>for some coefficients <span>$P^{nn&#39;}_\nu$</span>. We can determine these coefficients recursively as follows.</p><p class="math-container">\[\begin{aligned}
   \sum_\nu P^{n,n&#39;}_\nu J_\nu &amp;= J_n J_{n&#39;}\\
   %
   &amp;= J_n(x) (A_{n&#39;} x + B_{n&#39;}) J_{n&#39;-1} + C_{n&#39;} J_n(x) J_{n&#39;-2}(x)  \\
   %
   &amp;= \sum_\nu \bigg[ A_{n&#39;} x P^{n,n&#39;-1}_\nu J_\nu
         + B_{n&#39;} P^{n,n&#39;-1}_\nu J_\nu
         + C_{n&#39;} P^{n,n&#39;-2}_\nu J_\nu \bigg] = \dots
\end{aligned}\]</p><p>We rewrite</p><p class="math-container">\[   x J_\nu  = \frac{1}{A_{\nu+1}} J_{\nu+1} - \frac{B_{\nu+1}}{A_{\nu+1}} J_\nu
            - \frac{C_{\nu+1}}{A_{\nu+1}} J_{\nu-1}.\]</p><p>and insert this above, and then shift the summation indices, to obtain</p><p class="math-container">\[\begin{aligned}
   \dots
   &amp;=
   \sum_\nu \bigg[
         \frac{A_{n&#39;} P^{n,n&#39;-1}_\nu}{A_{\nu+1}} J_{\nu+1}
         - \frac{A_{n&#39;} P^{n,n&#39;-1}_\nu B_{\nu+1}}{A_{\nu+1}} J_\nu
         - \frac{A_{n&#39;} P^{n,n&#39;-1}_\nu C_{\nu+1}}{A_{\nu+1}} J_{\nu-1} \\
   &amp; \hspace{2cm}
         + B_{n&#39;} P^{n,n&#39;-1}_\nu J_\nu
         + C_{n&#39;} P^{n,n&#39;-2}_\nu J_\nu \bigg] \\
   &amp;= \sum_\nu \bigg[
         \frac{A_{n&#39;} P^{n,n&#39;-1}_{\nu-1}}{A_{\nu}}
         - \frac{A_{n&#39;} P^{n,n&#39;-1}_\nu B_{\nu+1}}{A_{\nu+1}}
         - \frac{A_{n&#39;} P^{n,n&#39;-1}_{\nu+1} C_{\nu+2}}{A_{\nu+2}}
         + B_{n&#39;} P^{n,n&#39;-1}_\nu
         + C_{n&#39;} P^{n,n&#39;-2}_\nu \bigg]  J_\nu  \\
\end{aligned}\]</p><p>Comparing coefficients we finally obtain</p><p class="math-container">\[      P^{n,n&#39;}_\nu
      =
      \frac{A_{n&#39;} P^{n,n&#39;-1}_{\nu-1}}{A_{\nu}}
      - \frac{A_{n&#39;} P^{n,n&#39;-1}_\nu B_{\nu+1}}{A_{\nu+1}}
      - \frac{A_{n&#39;} P^{n,n&#39;-1}_{\nu+1} C_{\nu+2}}{A_{\nu+2}}
      + B_{n&#39;} P^{n,n&#39;-1}_\nu
      + C_{n&#39;} P^{n,n&#39;-2}_\nu.\]</p><p>This calculation is valid verbatim if <span>$n&#39; &gt; 2$</span>. Since <span>$P^{n,n&#39;}_\nu$</span> is summetric in <span>$n, n&#39;$</span> we can choose whichever index <span>$n, n&#39;$</span> is larger and reduce the computation of the <span>$P^{n,n&#39;}_\nu$</span> to those of smaller <span>$(n, n&#39;)$</span> pairs. To treat the case <span>$n&#39; = 2$</span> we have to make the conventions that</p><p class="math-container">\[      B_1 = C_1 = C_2 = P^{n,0}_\nu = P^{n,n&#39;}_0 = 0.\]</p><p>This reduces the problem of precomputing the <span>$P^{n,n&#39;}_\nu$</span> coefficients to determining just <span>$P^{1,1}_\nu$</span>.</p><p>To determing <span>$P^{1,1}_\nu$</span> (the start of the recursion) we simply use the procedure proposed for the general case, i.e. by evaluating the inner product. If the inner product is not available then one could simply fit to randomly selected data points or suitably chosen interpolation nodes.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../purerecursion/">« Pure Basis Recursion</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 2 March 2021 13:57">Tuesday 2 March 2021</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
