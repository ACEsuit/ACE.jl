var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(this is an early draft of this document; please send me comments!)","category":"page"},{"location":"gettingstarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Install Julia, the latest versions of ACE.jl require v1.3 but should also work ok with v1.4, future versions will likely require v1.4.\nInstall the MolSim registry; from the Julia REPL, switch to package manager ] and then run","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"registry add https://github.com/JuliaMolSim/MolSim.git","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Install some important registered packages; from Julia REPL / package manager:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add PyCall IJulia     # add more important packages from General registry\nadd JuLIP ACE ASE   # maybe add other packages from MolSim registry","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"For fitting, need to install also IPFitting.jl,","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add IPFitting","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Keep fingers crossed and hope it will be compatible with the current version of ACE.jl...)","category":"page"},{"location":"gettingstarted/#Workflow","page":"Getting Started","title":"Workflow","text":"","category":"section"},{"location":"degree/#Notes-on-what-degree-means","page":"-","title":"Notes on what degree means","text":"","category":"section"},{"location":"degree/","page":"-","title":"-","text":"for the radial basis it seems natural that we want to use the index 1 as the first basis function and the degree is just the highest index.","category":"page"},{"location":"envpairbasis/#Pair-Potential-with-Environment","page":"ED-Bonds","title":"Pair Potential with Environment","text":"","category":"section"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"To be used either as an environment-dependent pair potential for modelling PES, or as an environment-dependent bond integral for TB models.","category":"page"},{"location":"envpairbasis/#Specification-of-the-basis","page":"ED-Bonds","title":"Specification of the basis","text":"","category":"section"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"The bond is defined by a vector barbm r,and the environment by vectors  bm r_j _j = 1^J. We assume that barbm r is vector between an atom at position bm 0 and barbm r. The vectors bm r_j are therefore relative to bm 0.","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"Alternatively, we could think of barbm r as describing the bond between two atoms at position pm frac12 barbm r and the bm r_j being distance vectors from bm 0 which is now the bond mid-point.","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"We think of the potential as being of the form","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"   Vbig( barbm r  bm r_j _j big)\n   = sum_N sum_j_1  dots  j_N\n   V_Nbig(barbm r  bm r_j_a _a = 1^N big)","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"We now construct a cylindrical coordinate system (r_j theta_j z_j) via","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"beginaligned\n  barr = barbm r \n  bm r_j = r_j cos theta_j bm e_x + r_j sintheta_j bm e_y\n               + z_j bm e_z\nendaligned","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"where the orthonormal frame bm e_x bm e_y bm e_z are defined by","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"   bm e_z = fracbarbm rbar r","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"and is otherwise chosen arbitrarily. The choice of bm e_xbm e_y are therefore only unique up to a rotation about the bm e_z axis, but since all quantities of interest will be rotation-invariant, this will not affect the results. (hopefully, depends on numerical stability!)","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"We now rewrite V_N in the form","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"   V_N = V_Nbig(bar r  bm c_j_a _a = 1^N big)\n   qquad bm c_j = (r_j theta_j z_j)","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"We expand into a polynomial basis,","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"   V_N sim sum_bm k bm l bm m\n   theta_barm bm klm\n   barP_barm(barr) times prod_a = 1^N P^r_k_a(r_j_a) e^i l_a theta_j_a P^z_m_a(z_j_a)","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"and apply the density trick,","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"beginaligned\n   mathcalV_N = sum_j_1  dots  j_N\n   V_Nbig(barbm r  bm r_j_a _a = 1^N big)  \n   sim\n   sum_bm k bm l bm m\n   theta_barm bm klm\n   prod_a = 1^N\n   A_barm k_a l_a m_a \n   \n   A_barm klm =\n      sum_j = 1^J phi_barmk l m(barr bm c_j) \n   phi_barmk l m(barr bm c_j)\n      = barP_barm(barr) P^r_k(r_j) e^i l theta_j P^z_m(z_j)\nendaligned","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"So we can simplify this to","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"beginaligned\n   A_barm klm\n   =\n   barP_barm(barr)\n   sum_j = 1^J\n   phi_k l m(bm c_j) \n   \n   phi_k l m(bm c_j)\n      = P^r_k(r_j) e^i l theta_j P^z_m(z_j)\nendaligned","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"This suggests the following assembly order","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"   mathcalV_N\n   sim\n   sum_bm klm A_bm klm sum_bar m theta_barmbm klm barP_barm(barr)","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"But this assumes that all barm have the same list of bm klm, which misses a lot of opportunity for sparsification. So if we want to keep the option to sparsify agressively, then we should keep","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"mathcalV_N\nsim\nsum_barm bm klm theta_barmbm klm barP_barm A_bm klm","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"To reduce storage one could still store the two arrays","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"      (barP_bar m)_bar m qquad (A_klm)_klm","category":"page"},{"location":"envpairbasis/","page":"ED-Bonds","title":"ED-Bonds","text":"separately rather than its tensor product.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This package implements approximation schemes for permutation and isometry invariant functions, with focus on modelling atomic interactions. It provides constructions of symmetric polynomial bases, imposing permutation and isometry invariance. Heavy use is made of trigonometric polynomials and spherical harmonics to obtain rotation invariance.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The main scheme currently implemented is based on the Atomic Cluster Expansion (ACE) described in","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). doi:10.1103/PhysRevB.99.014104","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A more detailed description and variations are discussed in","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"  M. Bachmayr, G. Csanyi, G. Dusson, S. Etter, C. van der Oord, and C. Ortner. Approximation of potential energy surfaces with spherical harmonics. arXiv:1911.03550v2; [http](https://arxiv.org/abs/1911.03550) [PDF](https://arxiv.org/pdf/1911.03550.pdf)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"There are also implementations of pure permutation invariant bases and of bases with only cylindrical symmetries for bond energies.","category":"page"},{"location":"devel/#Developer-Documentation","page":"Developer Docs","title":"Developer Documentation","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"warning: WARNING\nThis documentation described what will be implemented on the rewrite branch, and not what is currently implemented!","category":"page"},{"location":"devel/#General-Notes","page":"Developer Docs","title":"General Notes","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Always use Int for indexing, never Int16, Int32, etc.\nThere is a lot of switching between a species given by an AtomicNumber type and the index of that species in a list, given by an Int. Functions dispatch on Int vs AtomicNumber to make sure there is no confusion.","category":"page"},{"location":"devel/#Types-and-type-hierarchy","page":"Developer Docs","title":"Types and type hierarchy","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The ACE.jl package heavily utilizes composition (as opposed to inheritance), which is well aligned with Julia's type system and recommended style. Basis sets and calculators are built from the following two base types:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"OneParticleBasis : abstract supertype of a 1-particle basis\nPIBasis : concrete implementation of a permutation-invariant basis","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"For example, a rotation-invariant site energy basis set (ACE and extensions) RPIBasis is built from a PIBasis and the coupling coefficients. The PIBasis itself is specified in terms of the OneParticleBasis.","category":"page"},{"location":"devel/#One-Particle-Basis","page":"Developer Docs","title":"One Particle Basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A one-particle basis is a basis of functions phi_k  mathbbR^3 to mathbbR defined through a subtype of","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"abstract type OneParticleBasis end","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Concrete subtypes must be able to compute the projection of the atom density onto the one-particle basis:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"  A_k^z z_0(  (bm r_j z_j) _j = 1^J z_0 )\n   = sum_j  z_j = z phi_k^z_j z_0(bm r_j)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"where z_0 is the atom number of the centre-atom, and (bm r_j z_j) are relative positions and atom numbers of neighbours.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The \"standard\" evaluation of a single phi_k(bm r z z_0) is of course a special case. In addition, the gradients of individual basis functions, nabla phi_k(bm r z z_0) must be provided; this gradient is taken with respect to bm r.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Assuming that basis isa OneParticleBasis, this is done with the following interface:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A = alloc_B(basis)                # allocate storage for A = [ A_z for iz=1:NZ ]\ntmp = alloc_temp(basis, args...)        # allocate temporary arrays\nevaluate!(A, tmp, basis, Rs, Zs, z0)    # fill A = [ A_z for iz=1:NZ ]","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"For the gradients the following must be provided:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"dPhi = alloc_dB(basis)                     # storage for (∇ϕ_k)_k\ntmpd = alloc_temp_d(basis, args...)        # temporary storage\nevaluate_d!(dPhi, tmpd, basis, R, z, z0)   # fill dPhi with (∇ϕ_k)_k","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The interface does not require evaluate_d!(dPhi, tmpd, basis, Rs, Zs, z0).","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"There is a lot of code duplication in the implementation of OneParticleBasis, which we can avoid by a generic implementation of evaluate! which loops through all (R, z) in zip(Rs, Zs) and then calls","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"add_into_A!(A[iz], tmp, basis, R, iz, iz0)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"an implementation of OneParticleBasis then only needs to overload add_into_A! which should evaluate phi_k^z z_0(bm r) (where R represents bm r) and add these values into A[k]. For this to work, the type of the 1-particle basis must contain a field zlist which implements the interface defined by JuLIP.Potentials.ZList and JuLIP.Potentials.SZList.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"To build a PIBasis (see below) the OneParticleBasis musts also provide methods that specify it:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"get_basis_spec(basis::BasicPSH1pBasis, z0::AtomicNumber)\nget_basis_spec(basis::BasicPSH1pBasis, z0::AtomicNumber, i::Integer)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The first of these should return a Vector containing OnepBasisFcn objects that specify the list of 1-particle basis functions for a centre atom of species z0. The second method should return precisely the ith element of this vector. A concrete OneParticleBasis may either simply keep these specifications stored throughout its lifetime, or generate them on the fly, whichever is most convenient.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"note: Concrete subtypes of `OneParticleBasis`\nConcrete subtypes of OneParticleBasis areBasicPSH1PBasis : implemented and tested\nPSH1PBasis : parameterised version of BasicPSH1Basis; under construction\nBondEnv1PBasis : implemented in old code, needs to be ported\nTensor1PBasis : not yet doneShould revisit this and maybe add another abstract layer in-between since all of these are really tensor product bases! (Reference relevant sections below)","category":"page"},{"location":"devel/#Permutation-Invariant-Basis","page":"Developer Docs","title":"Permutation-Invariant Basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The permutation-invariant basis is a concrete type","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"struct PIBasis end","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"which implements the tensor-product like basis functions","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   bm A_bm z bm k^z_0\n   =\n   prod_alpha = 1^N A_k_alpha^z_alpha z_0\n   qquad textwhere quad\n   bm z in mathbbZ^N bm k in mathbbN^N","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"as well as the gradients","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   fracpartial A_bm z bm k^z_0partial bm r_j","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The interface for this is as follows:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"alloc_B(pibasis::PIBasis)\nalloc_tmp(pibasis::PIBasis)\nevaluate!(AA, tmp, pibasis, Rs, Zs, z0)\nalloc_dB(pibasis::PIBasis)\nalloc_tmp_d(pibasis::PIBasis)\nevaluate_d!(dAA, tmp, pibasis, Rs, Zs, z0)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"where the storage arrays are","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"AA::Vector{<: Number} : to store any AA_kk^{zz, z0} with z0 fixed, i.e. the AA vector for a single site only. To use a PIBasis as the actual basis rather than an auxiliary one should wrap it (see bonds – TODO!)\ndAA::Matrix{<: JVec} with dimension basis-length x number of particles","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"We don't provide a detailed description here of the implementation, since it is already the final product. But we can summarize the functionality that is provided that can be used to construct further basis sets from it.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"TODO","category":"page"},{"location":"devel/#Generating-a-OneParticleBasis-and-PIBasis-via-gen_sparse","page":"Developer Docs","title":"Generating a OneParticleBasis and PIBasis via gen_sparse","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"TODO","category":"page"},{"location":"devel/#Derived-Potentials","page":"Developer Docs","title":"Derived Potentials","text":"","category":"section"},{"location":"devel/#RPI-Basis-(ACE-and-Extensions)","page":"Developer Docs","title":"RPI Basis (ACE and Extensions)","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The ACE basis (Atomic Cluster Expansion; Drautz 2019) and its modifications and extensions is one of the main user-facing objects provided by ACE.jl. It is constructed by reducing a permutation invariant PIBasis to a permutation and rotation invariant basis through a single sparse matrix-vector multiplication.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":" B = C cdot bm A","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"where B is the new RPI basis, bm A the \"inner\" PI basis and C the coupling coefficients that achieve the rotation-invariance. This relies on a specific choice of the one-particle basis. This construction is outlined in (Atomic Cluster Expansion; Drautz 2019) and an extended derivation with full details in (Bachmayr, Drautz, Dusson, Etter, Van der Oort, Csanyi, Ortner, arXiv:19..). The implementation of the C coefficients in rpi/rotations3d.jl is based on a numerical SVD as opposed to an analytic SVD.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The RPIBasis type stores only three fields: the PIBasis, the coefficients C, and some index management to map the local site basis into a global basis (only needed for multiple species).","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"TODO: discuss the classes of 1-particle bases that are allowed.","category":"page"},{"location":"devel/#Bond-Environment-Potentials","page":"Developer Docs","title":"Bond-Environment Potentials","text":"","category":"section"},{"location":"pureintro/#What-is-Pure-ACE","page":"What is Pure ACE","title":"What is Pure ACE","text":"","category":"section"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"The standard ACE basis is given by the O(3)-symmetrised nu-correlations. Ignoring the O(3)-symmetry for a moment, we are talking about","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"A_bf k = prod_alpha A_k_alpha","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"where","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"   A_k = sum_j phi_k(bm r_j)","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"Another way to write this is,","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"A_bf k\n=\nsum_j_1 j_2 dots j_nu\n   prod_alpha = 1^nu\n   phi_k_alpha(bm r_j_alpha)","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"which shows the potentially unwelcome self-interaction terms.","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"On the other hand, the \"naive\" summetrised nu-order interaction is given by","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"   mathcalA_bm k =\n   frac1nu sum_sigma in S_nu phi_bm k circ sigma","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"We call this the \"pure\" ACE basis because it contains no self-interactions; indeed, another way to write it is","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"   mathcalA_bm k\n   =\n   sum_j_1  cdots  j_nu\n   prod_alpha = 1^nu\n      phi_k_alpha( bm r_j_alpha )","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"Maybe we shouldn't care about this at all, but this is far from clear. First it is chemically more intuitive to work with this basis and maybe this has some advantages in constructing or sparsifying good models. But from a purely numerical perspective there is the problem that the standard ACE basis is ill-conditioned for large body-orders.  However, if the phi_bm k are orthogonal, then this orthogonality is inherited by the mathcalB_bm k. (TODO: some subtle points - insert details)","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"Having an orthogonal basis has clear theoretical advantages and it gives us the opportunity to explore whether these translate also into practical advantages.","category":"page"},{"location":"purerecursion/#Pure-Basis-Recursion","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"The idea is to exploit the DAG representation of the pi-ACE basis A_bf k to recursively construct the pure basis mathcalA_bm k.","category":"page"},{"location":"purerecursion/#correlations-(2-body)","page":"Pure Basis Recursion","title":"1-correlations (2-body)","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"For the 1-correlations, there is nothing to do since","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"\n   A_k = mathcalA_k qquad forall k","category":"page"},{"location":"purerecursion/#correlations-(3-body)","page":"Pure Basis Recursion","title":"2-correlations (3-body)","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"If bm k = (k_1 k_2) then the connection bm k = (k_1) cup (k_2) is already the DAG. We can now write","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"beginaligned\n   A_k_1 k_2\n   =\n   sum_j_1 j_2 phi_k_1(bm r_j_1) phi_k_2(bm r_j_2) \n   =\n   sum_j_1 neq j_2 phi_k_1(bm r_j_1) phi_k_2(bm r_j_2)\n   + sum_j_1 phi_k_1(bm r_j_1) phi_k_2(bm r_j_1)\nendaligned","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"or, conversely,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_k_1 k_2\n   =\n   A_k_1 k_2 - sum_j_1 phi_k_1(bm r_j_1) phi_k_2(bm r_j_1)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"Next we observe that the product of polynomials phi_k_1 phi_k_2 is again a polynomial, i.e.,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   phi_k_1 phi_k_2\n   = sum_K P_k_1 k_2^K phi_K","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"hence, we can write","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_k_1 k_2\n   =\n   A_k_1 k_2 - sum_K P_k_1 k_2^K A_K","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"The computation of the product coefficients P_k_1 k_2^K will be discussed  Products of Polynomials.","category":"page"},{"location":"purerecursion/#General-correlations","page":"Pure Basis Recursion","title":"General correlations","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"For general bm k = (k_1 dots k_nu), the DAG provides a recursion","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   bm k = bm k cup bm k","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"where","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   bm k = (k_1 dots k_nu) qquad\n   bm k = (k_nu+1 dots k_nu)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"with nu = nu - nu.","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"Since we already have access to mathcalA_bm k mathcalA_bm k we can start from those objects,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_bm k mathcalA_bm k\n   =\n   sum_j_1 neq dots neq j_nu\n   sum_j_nu neq cdots neq j_nu\n   prod_alpha = 1^nu phi_k_alpha(bm r_j_alpha)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"The challenge now is to convert this into a sum_j_1 neq cdots neq j_nu. For a general recursion  bm k = bm k cup bm k this looks quite difficult.","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"Let us assume that nu leq nu then we can write","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   sum_j_1 neq dots neq j_nu\n   sum_j_nu neq cdots neq j_nu\n   =\n   sum_0 textmatches +\n   sum_1 textmatches\n   + cdots +\n   sum_nu textmatches","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"where","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   sum_p textmatches\n   =\n   sum_substack\n         j_1 neq cdots neq j_nu \n         j_nu+1 neq cdots neq j_nu \n           j_1 dots j_nu  cap j_nu+1 dots j_nu = p","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"Clearly,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   sum_0 textmatches\n   =\n   sum_j_1 neq cdots neq j_nu","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"i.e. this is the term we want to keep. It remains to express sum_p textmatches in terms of A_bm k with mathcalA_bm k with rm len(bm k)  nu. It appears that for p there are","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   binomnup\n      cdot\n   binomnup","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"sums to evaluate. This cost clearly explodes rapidly with increasing body-order.","category":"page"},{"location":"purerecursion/#Simplified-recursion","page":"Pure Basis Recursion","title":"Simplified recursion","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"To control this cost we can replace an optimized DAG with a much simpler DAG that contains only decompositions bm k = bm k cup (k_nu+1) (note the modified notation to avoid clutter below). In this case, the term we need to manipulate is","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"beginaligned\n   mathcalA_bm k A_k_nu+1\n   =\n   sum_j_1 neq cdots neq j_nu sum_j_nu+1 prod_alpha = 1^nu+1 phi_k_alpha(r_j_alpha) \n   =\n   sum_j_1 neq cdots neq j_nu neq j_nu+1 prod_alpha = 1^nu+1 phi_k_alpha(r_j_alpha)\n   +\n   sum_beta = 1^nu sum_j_1 neq cdots neq j_nu\n      phi_k_nu+1(r_j_beta) prod_alpha = 1^nu phi_k_alpha(r_j_alpha)\nendaligned","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"We can now insert the expression for Products of Polynomials to write","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   sum_j_beta phi_k_beta(r_j_beta) phi_k_nu+1(r_j_beta)\n   =\n   sum_K P_k_beta k_nu+1^K\n   sum_j_beta phi_K(r_j_beta)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"and obtain","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_bm k A_k_nu+1\n   =\n   mathcalA_(bm k k_nu+1)\n   +\n   sum_beta = 1^nu\n   sum_K P_k_beta k_nu+1^K\n   mathcalA_bm kbeta","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"where","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   bm kbeta = (k_1 dots k_beta-1 K k_beta+1 dots k_nu)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"With this definition we have obtained a recursive expression the pure mathcalA PI basis,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_(bm k k_nu+1)\n   =\n   mathcalA_bm k A_k_nu+1\n   -\n   sum_beta = 1^nu\n   sum_K P_k_beta k_nu+1^K\n   mathcalA_bm kbeta","category":"page"},{"location":"#ACE.jl-Documentation","page":"Home","title":"ACE.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements approximation schemes for permutation and isometry invariant functions, with focus on modelling atomic interactions. It provides constructions of symmetric polynomial bases, imposing permutation and isometry invariance. Heavy use is made of trigonometric polynomials and spherical harmonics to obtain rotation invariance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"intro.md\",\n         \"gettingstarted.md\",\n         \"devel.md\",\n         \"envpairbasis.md\",\n         \"polyproducts.md\"]\nDepth = 1","category":"page"},{"location":"polyproducts/#Products-of-Polynomials","page":"Products of Polynomials","title":"Products of Polynomials","text":"","category":"section"},{"location":"polyproducts/#Products-of-Radial-Polynomials","page":"Products of Polynomials","title":"Products of Radial Polynomials","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Suppose we have a basis of orthonormal radial polynomials","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":" (J_n J_n)_w = delta_nn","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where (cdot cdot)_w is any inner product we choose. Product J_n_1 J_n_2 are again polynomials and can therefore be expanded in terms of the basis J_nu, i.e.,","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   J_n_1 J_n_2 = sum_nu P_n_1 n_2^nu J_nu","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Because they are orthonormal, the expansion coefficients are simply given by","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   P_n_1 n_2^nu = ( J_n_1 J_n_2 J_nu)_w","category":"page"},{"location":"polyproducts/#Implementation","page":"Products of Polynomials","title":"Implementation","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The radial polynomial products are implemented in `src/polynomials/products.jl' in a lazy datastructure.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"struct OrthPolyProdCoeffs","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"If prodcoeffs::OrthPolyProdCoeffs then calling","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"P = prodcoeffs(n1, n2)","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"returns a vector P such that P[nu] is the value of P^n_1n_2_nu, allowing indices nu in mathbbZ. Coefficients outside the actual range will simply be zero. The coefficient vectors are computed lazyly, i.e., will only be precomputed when required but then stored for later use.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The precomputation is done by explicit evaluation of the inner products as described above.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Alternatively we can access P_n_1 n_2^nu with an iterator","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"for (nu, Pnu) in coeffs(n1, n2)\n   # ...\nend","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"will iterate only over the non-zero coefficients.","category":"page"},{"location":"polyproducts/#The-case-of-Chebyshev-Polynomials-(TODO)","page":"Products of Polynomials","title":"The case of Chebyshev Polynomials (TODO)","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The simplest case is that of monomials J_n = x^n (x - x_l)^p_l (x - x_r)^p_r). The product J_n_1 J_n_2 can then by written with just five non-zero coefficients P_n_1 n_2^N. But monomials lead to sever numerical instabilities.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The \"next-best\" option in terms of sparsity of the product coefficients appear to be Chebyshev polynomials.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   2 T_m(x) T_n(x) = T_m+n(x) + T_m-n(x)","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"That is if we choose","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   J_n = T_n+1 f_rm cut","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"then","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   J_n_1 J_n_2 = T_n_1+1 T_n_2+1 f_rm cut f_rm cut","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"For N_p = p_l + p_r we have","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   f_rm cut = sum_n = 0^N_p T_n","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"hence","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   J_n_1 J_n_2\n   =\n   sum_n = 0^N_p T_n_1+1 T_n_2+1 T_n f_rm cut \n   =\n   frac12 sum_n = 0^N_p big( T_n+1+n_2+2 + T_n_1-n_2 big) T_n f_rm cut  \n   =\n   frac12 sum_n = 0^N_p Big(\n           T_n+1+n_2+2 + n + T_n_1+n_2+2 - n\n         + T_n_1-n_2 + n + T_ n_1-n_2 - n  Big) f_rm cut\nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"This means that there are at most 4 (N_p + 1). non-zero coefficients, independently of the chosen maximum degree.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"In practise it is quite likely that this makes little difference. We normally choose p_l = p_r = 2 which leads to approx. 20 non-zero coefficients. But this is already close to the maximum degree we allow, hence for a general basis we will see little gain. An interesting question, maybe, is whether numerical stability is improved for a Chebyshev basis because of the explicit analytic recursion.","category":"page"},{"location":"polyproducts/#Products-of-spherical-harmonics","page":"Products of Polynomials","title":"Products of spherical harmonics","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"A product of two spherical harmonics can again be expanded in terms of spherical harmonics,","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   Y_l_1^m_1 Y_l_2^m_2\n       = sum_lambda mu P_l_1 m_1 l_2 m_2^lambda mu Y_lambda^mu","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where the \"coupling coefficients\" are given by","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   P_l_1 m_1 l_2 m_2^lambda mu\n   =\n   sqrtfrac(2l_1+1)(2l_2+1)2pi (2lambda+1) \n   C_l_1 m_1 l_2 m_2^LM C_l_1 0 l_2 0^L0","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where C_l_1 m_1 l_2 m_2^LM are the Clebsch-Gordan coefficients. These are non-zero only for","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n    l_1 - l_2 leq L leq l_1 + l_2 \n    M = m_1 + m_2 \n    M leq L m_i leq l_i \n    l_1 + l_2 - L text is even","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The first three of these conditions are the conditions for C_l_1 m_1 l_2 m_2^LM to be non-zero. The fourth condition follows from the fact that","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   C_l_1 m_1 l_2 m_2^L M =\n   (-1)^l_1 + l_2 - L C_l_1 (-m_1) l_2 (-m_2)^L (-M)","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"and hence C_l_1 0 l_2 0^L0 can only be non-zero if l_1 + l_2 - L is even.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"These conditions ensure that the P_l_1 m_1 l_2 m_2^L M coefficients are extremely sparse. This is exploited when iterating over all required L M.","category":"page"},{"location":"polyproducts/#Implementation-2","page":"Products of Polynomials","title":"Implementation","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The coefficients P_l_1 m_1 l_2 m_2^lambda mu are implemented in the datastructure","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"struct SHProdCoeffs","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"To get the coefficients for a specific l1, m1, l2, m2 we can call","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"P = coeffs(l1, m1, l2, m2)","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where coeffs::SHProdCoeffs. To iterate over all non-zero coefficients,","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"for (L, M, p) in P\n   # ...\nend","category":"page"},{"location":"polyproducts/#Products-of-one-particle-basis-function","page":"Products of Polynomials","title":"Products of one-particle basis function","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   phi_n_1 l_1 m_1 phi_n_2 l_2 m_2\n   =\n   R_n_1 Y_l_1^m_1 R_n_2 Y_l_2^m_2  \n   =\n   sum_N P_n_1n_2^N R_N sum_L M P_l_1m_1l_2m_2^LM Y_L^M\nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"This means we have","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   phi_k_1 phi_k_2 =\n   sum_K P_k_1 k_2^K phi_k","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where k = (n l m) and","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   P_k_1 k_2^K = P_n_1n_2^N P_l_1m_1l_2m_2^LM","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The tensor product structure can be exploited in code if many such products have to be computed.","category":"page"},{"location":"polyproducts/#Appendices","page":"Products of Polynomials","title":"Appendices","text":"","category":"section"},{"location":"polyproducts/#Three-term-recurrance","page":"Products of Polynomials","title":"Three-term recurrance","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"If the polynomials satisfy a three-term recurrance then there is an alternative way to obtain the product coefficients which does not require evaluating the inner products. This is currently not implemented, but we keep it here as a record for the future.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Suppose we have a radial polynomial basis satisfying the recursion","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   J_1(x) = A_1 (x - x_l)^p_l (x - x_r)^p_r \n   J_2 = (A_2 x + B_2) J_1(x) \n   J_n = (A_n x + B_n) J_n-1(x) + C_n J_n-2(x)\nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"For the save of brevity, we will write f_rm cut = (x - x_l)^p_l (x - x_r)^p_r, o.e., J_1 = A_1 f_rm cut. The functions J_n span the space of all polynomials that are multiples of f_rm cut.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Since f_rm cut divides all J_n, if we take a product p = J_n(x) J_n(x) then f_rm cut also divides p and in particular p = q f_rm cut. Since q is itself a polynomials it follows that","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":" p = sum_nu = 1^n+n+p_l + p_r P^n n_nu J_nu","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"for some coefficients P^nn_nu. We can determine these coefficients recursively as follows.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   sum_nu P^nn_nu J_nu = J_n J_n\n   \n   = J_n(x) (A_n x + B_n) J_n-1 + C_n J_n(x) J_n-2(x)  \n   \n   = sum_nu bigg A_n x P^nn-1_nu J_nu\n         + B_n P^nn-1_nu J_nu\n         + C_n P^nn-2_nu J_nu bigg = dots\nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"We rewrite","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   x J_nu  = frac1A_nu+1 J_nu+1 - fracB_nu+1A_nu+1 J_nu\n            - fracC_nu+1A_nu+1 J_nu-1","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"and insert this above, and then shift the summation indices, to obtain","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   dots\n   =\n   sum_nu bigg\n         fracA_n P^nn-1_nuA_nu+1 J_nu+1\n         - fracA_n P^nn-1_nu B_nu+1A_nu+1 J_nu\n         - fracA_n P^nn-1_nu C_nu+1A_nu+1 J_nu-1 \n    hspace2cm\n         + B_n P^nn-1_nu J_nu\n         + C_n P^nn-2_nu J_nu bigg \n   = sum_nu bigg\n         fracA_n P^nn-1_nu-1A_nu\n         - fracA_n P^nn-1_nu B_nu+1A_nu+1\n         - fracA_n P^nn-1_nu+1 C_nu+2A_nu+2\n         + B_n P^nn-1_nu\n         + C_n P^nn-2_nu bigg  J_nu  \nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Comparing coefficients we finally obtain","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"      P^nn_nu\n      =\n      fracA_n P^nn-1_nu-1A_nu\n      - fracA_n P^nn-1_nu B_nu+1A_nu+1\n      - fracA_n P^nn-1_nu+1 C_nu+2A_nu+2\n      + B_n P^nn-1_nu\n      + C_n P^nn-2_nu","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"This calculation is valid verbatim if n  2. Since P^nn_nu is summetric in n n we can choose whichever index n n is larger and reduce the computation of the P^nn_nu to those of smaller (n n) pairs. To treat the case n = 2 we have to make the conventions that","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"      B_1 = C_1 = C_2 = P^n0_nu = P^nn_0 = 0","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"This reduces the problem of precomputing the P^nn_nu coefficients to determining just P^11_nu.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"To determing P^11_nu (the start of the recursion) we simply use the procedure proposed for the general case, i.e. by evaluating the inner product. If the inner product is not available then one could simply fit to randomly selected data points or suitably chosen interpolation nodes.","category":"page"}]
}
