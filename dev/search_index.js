var documenterSearchIndex = {"docs":
[{"location":"degree/#Notes-on-what-degree-means","page":"-","title":"Notes on what degree means","text":"","category":"section"},{"location":"degree/","page":"-","title":"-","text":"for the radial basis it seems natural that we want to use the index 1 as the first basis function and the degree is just the highest index.","category":"page"},{"location":"pureintro/#What-is-Pure-ACE","page":"-","title":"What is Pure ACE","text":"","category":"section"},{"location":"pureintro/","page":"-","title":"-","text":"The standard ACE basis is given by the O(3)-symmetrised nu-correlations. Ignoring the O(3)-symmetry for a moment, we are talking about","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"A_bf k = prod_alpha A_k_alpha","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"where","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"   A_k = sum_j phi_k(bm r_j)","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"Another way to write this is,","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"A_bf k\n=\nsum_j_1 j_2 dots j_nu\n   prod_alpha = 1^nu\n   phi_k_alpha(bm r_j_alpha)","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"which shows the potentially unwelcome self-interaction terms.","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"On the other hand, the \"naive\" summetrised nu-order interaction is given by","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"   mathcalA_bm k =\n   frac1nu sum_sigma in S_nu phi_bm k circ sigma","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"We call this the \"pure\" ACE basis because it contains no self-interactions; indeed, another way to write it is","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"   mathcalA_bm k\n   =\n   sum_j_1  cdots  j_nu\n   prod_alpha = 1^nu\n      phi_k_alpha( bm r_j_alpha )","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"Maybe we shouldn't care about this at all, but this is far from clear. First it is chemically more intuitive to work with this basis and maybe this has some advantages in constructing or sparsifying good models. But from a purely numerical perspective there is the problem that the standard ACE basis is ill-conditioned for large body-orders.  However, if the phi_bm k are orthogonal, then this orthogonality is inherited by the mathcalB_bm k. (TODO: some subtle points - insert details)","category":"page"},{"location":"pureintro/","page":"-","title":"-","text":"Having an orthogonal basis has clear theoretical advantages and it gives us the opportunity to explore whether these translate also into practical advantages.","category":"page"},{"location":"devel/#Developer-Documentation-/-Internals","page":"Developer Docs","title":"Developer Documentation / Internals","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"CurrentModule = ACE","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"warning: WARNING\nThis documentation is very much a work in progress since the general framework for ACE.jl has only slowly been developing. There are likely leftovers from earlier version. That said, the framework is now slowly establishing itself, and documentation will now get updated and improved over time. Please file issues, ask questions or make PRs. ","category":"page"},{"location":"devel/#Summary-of-types-and-type-hierarchy","page":"Developer Docs","title":"Summary of types and type hierarchy","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The ACE.jl package heavily utilizes composition (as opposed to inheritance), which is well aligned with Julia's type system and recommended style. Basis sets and calculators are built from the following base types.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"OneParticleBasis : abstract supertype of a 1-particle basis\nPIBasis : concrete implementation of a permutation-invariant basis, employing a OneParticleBasis and a specification of all possible correlations\nSymmetricBasis : implementation of the \"coupling\" to achieve additional symmetries, e.g. O(3)\nLinearACEModel : representation of one or more properties in terms of a basis.","category":"page"},{"location":"devel/#States-and-Configurations-(Inputs)","page":"Developer Docs","title":"States and Configurations (Inputs)","text":"","category":"section"},{"location":"devel/#States","page":"Developer Docs","title":"States","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Each particle is described by one or more variables, including e.g. its position, species, spin, charge, etc. The input space mathbbX is simply the space in which those variables reside. The input variable must be a subtype AbstractState following some strict conventions.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"In practise one would most likely use the State type which simply wraps a NamedTuple. E.g. if we wanted a particle that only has a position we could define this as ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"X = State(rr = rand(SVector{3, Float64}))","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"If we have a particle that has position rr and species Z attributes, and maybe an invariant feature u, then we would define this as ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"X = State(rr = rand(SVector{3, Float64}), Z = 13, u = rand())","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The data can be accessed via . or getproperty.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"It is crucial that the attributes/features rr, Z, u are known to the one-particle basis, i.e. when evaluating phi_v(X) the one-particle basis phi_v must \"know\" that it can obtain the position by calling X.rr; more on this below. ","category":"page"},{"location":"devel/#Configurations","page":"Developer Docs","title":"Configurations","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A collection of states is a configuration. The supertype for configurations is AbstractACEConfiguration. The simples concrete implementatin is ACEConfiguration which simply wraps a Vector{<: AbstractState}. Configurations must be iterable. Example: ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"cfg = ACEConfig( [ State(rr = randn(SVector{3, Float64})) for _=1:10 ])","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"creates a configuration containing 10 particles having only a position as an attribute.","category":"page"},{"location":"devel/#DStates","page":"Developer Docs","title":"DStates","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"While a State is just a description of an object, a DState can be thought of as an element of a vector space which we can manipulate. A classical analogy is that a State might be a point while a DState a vector pointing to it. E.g. we can add two DStates or multipy them with a scalar. This is not allowed for a State. This places certain restrictions on what a DState might contain. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The main application of this in ACE.jl is that DStates are derivatives of States. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"TODO: write a more thorough explanation and how they are used and constructed. ","category":"page"},{"location":"devel/#One-Particle-Basis","page":"Developer Docs","title":"One Particle Basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The one-particle basis is arguably the most important object in defining an ACE model. It is the fundamental building block for reprenting an input, before the generic methods/algorithms for correlatons and symmetrisation take over.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A one-particle basis is a basis of functions phi_v  mathbbX to mathbbC (or, mathbbR) defined through a subtype of","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"abstract type OneParticleBasis end","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Concrete subtypes must implement the projection of the atom density onto the one-particle basis, ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"  A_v(  X_j _j ) = sum_j phi_v(X_j)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"This is done with the following interface:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A = ...      # allocate storage for A = [ A_z for iz=1:NZ ]\nevaluate!(A, basis1p, cfg)    # fill A = [ A_z for iz=1:NZ ]","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"In practise this would more conveniently be called via","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A = evaluate(basis1p, cfg)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"with the allocation occuring behind the scenes. Normally, basis1p will have an object pool implemented, then the array A when no longer needed can be returned to the pool via ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"release_B!(basis1p, A)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"For example when 1p-basis evaluate occurs as part of the full ACE model, then all allocations occur at a suitable point in the evaluation chain. The user need not be concerned about this. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"There is a lot of code duplication in the implementation of OneParticleBasis, which we can avoid by a generic implementation of evaluate! which loops through all X in Xs and then calls","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"add_into_A!(A, basis1p, X)\n# should be equivalent to A[:] += evaluate(basis1p, X)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"an implementation of OneParticleBasis then only needs to overload add_into_A! which evaluates all phi_v at one state pair X and adds the basis values into a pre-allocated vector A.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Although in most cases AD and backpropagation will be used to take gradients, for performance reasons it is important to have hand-coded gradients for the 1p-basis implementations. For the gradients w.r.t. a single state the following must be provided:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"dPhi =  .....                     # storage for (∇ϕ_k)_k\nevaluate_d!(dPhi, basis1p, X)     # fill dPhi with (∇ϕ_k)_k","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The interface does not require evaluate_d!(dPhi, basis1p, cfg), which is done behind the scenes (see oneparticlebasis.jl). ","category":"page"},{"location":"devel/#Basis-Indexing","page":"Developer Docs","title":"Basis Indexing","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"To build a PIBasis (see below) the OneParticleBasis musts also provide methods that specify it:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"get_spec(basis, i::Integer)   # specification of the ith basis function\nget_spec(basis)               # vector containing all basis function specs","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A basis function is specified as a NamedTuple. For instance, in the above example the values of the mu n l m indices would specify phi_mu n l m. Thus the basis function is specified by","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   b = (μ = ..., n = ..., l = ..., m = ...)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"This framework is particularly useful if some tuples overlap across different components of a product one-particle basis. For example, if R_n depends also on the species, or if the radial basis is given as R_nl.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"To let the generic code know which indices are available and what the range of each index is the one-particle basis must implement symbols and indexrange.","category":"page"},{"location":"devel/#Notes","page":"Developer Docs","title":"Notes","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"note: Bonds vs Sites\nThe theory allows some extensions that are currently only accessible through an ad hoc \"hack\", but which may turn out to be the best strategy to implement them anyhow: The most important case is that when modelling e.g. an atomic environment, the one-particle basis may also depend on the center-atom, which could be written as    math       A_v = \\sum_{j} \\phi_v(X_j, X_i).   This is not directly supported. Instead one should simply identify a state X_j with the state of the bond (X_i X_j) and include the attributes of the center-atom in X_j. For example, if phi_v depends also on the species of atoms i j, this might take the form    julia       X_j = State(rr = position[j] - position[i], Z = Z[j], Z0 = Z[i])","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"note: TODO - vectorisation\nIt could be worth enabling the possibility to overload evaluate_d!(dPhi, basis1p, cfg) for faster evaluation, e.g. AVX, GPU acceleration. This hasn't been explored at all yet. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"warning: WARNING\nThe gradient interface is not really done yet and may need more design work! The issue remaining is to decide how to manage the situation that gradient with only specific attributes of a state might be required but not w.r.t. the entire state. This is the main open problem in the current redesign of ACE.jl ","category":"page"},{"location":"devel/#Product-1p-Basis","page":"Developer Docs","title":"Product 1p-Basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The most common situation is that basis1p is a product of basis functions acting on different variables. This can be constructed using Product1pBasis. For example, a one-particle basis of the kind","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   phi_mu n l m(X) = delta(mu_X - mu) R_n(r_X) Y_l^m(bm r_X)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"can be constructed as","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Bμ = Species1PBasis(species)\nRn = Rn1pBasis(ACE.Utils.radial_basis())\nYlm = Ylm1pBasis(10)\nbasis1p = Product1pBasis( (Bμ, Rn, Ylm) )","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Components from which to build a Product1pBasis are listed below.","category":"page"},{"location":"devel/#Concrete-Implementations-of-One-particle-Bases","page":"Developer Docs","title":"Concrete Implementations of One-particle Bases","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Rn1pBasis : radial basis of type R_n(r) wrapping an orthogonal polynomial basis in transformed coordinates. \nYlm1pBasis : wrapping complex spherical harmonics \nScal1pBasis : a generic scalar 1p basis component. It differs from Rn1pBasis in that it takes a scalar as input while Rn1pBasis takes a vector and transforms it to a scalar via norm. In hindsight, these two codes should probably be compined streamlined into a single one.\nACEatoms.jl provides also a species-1p-basis; see docs for ACEatoms.jl\nwip: discrete, one-hot, Fourier, other symmetries","category":"page"},{"location":"devel/#Permutation-Invariant-Basis","page":"Developer Docs","title":"Permutation-Invariant Basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The permutation-invariant basis is a concrete type","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"struct PIBasis end","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"which implements the N-correlations which can be thought of as  tensor-product like basis functions","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   bm A_bm v\n   =\n   prod_t = 1^N A_v_t\n   qquad textwhere quad\n   bm v in mathbbN^N","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The (naive) interface for this is as follows:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"evaluate!(AA, pibasis, cfg)\nevaluate_ed!(AA, dAA, pibasis, cfg)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"where the storage arrays are","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"AA::Vector{<: Number} : to store any AA_kk^{zz, z0} with z0 fixed, i.e. the AA vector for a single site only. To use a PIBasis as the actual basis rather than an auxiliary one should wrap it (see bonds – TODO!)\ndAA::Matrix{<: ??} with dimension basis-length x number of particles, the eltype is specified by what the derivatives of the states are. E.g. if the states are described by a State then dAA::Matrix{<: DState}","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"There are two implementations for evaluating the a PIBasis, one based on explicitly going through the loop prod_t, the other on a recursive evaluation via a DAG (currently disabled). TODO: need to re-enable this, and add references.","category":"page"},{"location":"devel/#Generating-a-OneParticleBasis-and-PIBasis,-and-BasisSelectors","page":"Developer Docs","title":"Generating a OneParticleBasis and PIBasis, and BasisSelectors","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A 1p basis function is defined by a NamedTuple. For example, for an R_n Y_l^m basis or an R_nl Y_l^m basis a 1p basis function would be specified (e.g.) by a tuple ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"     (n = 3, l = 2, m = -1)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"where 3, 2, -1 just stand for possible values for the basis indices n, l, m. Of course we could define the basis indices to be calles nr, lr, mr and then the tuple would be (nr = 3, lr = 2, mr = -1). ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Creating a 1p basis requires generating the list of all tuples specifying the 1p basis functions. This occurs in init1pspec!, called via ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"init1pspec!(B1p, Bsel)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"where B1p is the 1p basis and Bsel a basis selector which specifies which of the tuples will be part of the basis specification. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A pi basis function (product basis function) is specified via a vector of NamedTuples. The the specification is gives as a list of such vectors of namedtuples and is normally generated via gensparse. gensparse uses implicitly uses again a basis selector to determine which basis functions to keep. ","category":"page"},{"location":"devel/#Basis-Selectors","page":"Developer Docs","title":"Basis Selectors","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A basis selector Bsel must specify: ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"degree : several methods to assign a degree to a basis function; this is required since in some places we need an ordering the 1p basis functions \nisadmissible : decide whether a basis function is part of the basis or not \nmaxorder : the larged correlation-order to be generated in the basis","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"For example SimpleSparseBasis is implemented as follows (sketch)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"struct SimpleSparseBasis <: DownsetBasisSelector\n   maxorder::Int\n   maxdeg::Float64\nend","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The degree of a 1p basis function is specified by the 1p basis itself. Next, isadmissible is defined as isadmissible = degree <= maxdeg. And maxorder is simply a user-defined parameter. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"But arbitrarily complex basis selectors could be implemented as long as they specify downsets in the lattice of all possible basis functions. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A very useful implementation is the SparseBasis which allows giving different weights to the different basis indices, e.g., one might want to give l a higher weight than n if one believes that fewer angular basis functions than radial basis functions are required. Another idea is to use difference degrees for different correlation orders, or rather than a total degree one could use different kinds of norms in the basis function lattice.","category":"page"},{"location":"devel/#Properties-and-symmetries","page":"Developer Docs","title":"Properties and symmetries","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A property varphi is the output of an ACE model. Each property has certain symmetries attached to it. For example, an invariant varphi satisfies","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   varphi circ Q = varphi","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A covariant Euclidean vector varphi in mathbbR^3 satisfies","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   varphi circ Q = Q varphi","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"An equi-variant spherical vector varphi satisfies,","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   varphi circ Q = D(Q) varphi","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"and there are many more options as we move to higher-order tensors.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"To model these symmetries we introduce the SymmetricBasis in the next section. To generate it a property must specify what its symmetries are.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"All properties must be subtypes of AbstractProperty. For example","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"struct InvariantT  AbstractProperty\n   valT\nend","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The actual value(s) should always be encoded in the field val since this allows for generic implementation of several methods required for properties, such as arithmetic operations.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"note: TODO\ndiscuss the interface how the properties specify their symmetry. For the    moment this can be looked up in properties.jl. It is done through the    initial condition for the coupling coefficient recursion.","category":"page"},{"location":"devel/#The-symmetric-basis","page":"Developer Docs","title":"The symmetric basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A key aspect of ACE.jl is to treat permutation symmetry AND additional possibly continuous symmetries, O(3) being the main prototype. Other symmetries are WIP, in particular general O(d) and  O(d1 d2), but we plan to also provide U(n) and maybe others. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Given a property varphi which has certain symmetries attached to it we want to generate a basis mathbfB which respects these symmetries as well. In ACE.jl this is provided by the SymmetricBasis type, which transforms from the density correlation basis mathbfA to a symmetry adapted variant by computing all possible couplings of the spherical harmonics that produce the desired symmetry.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":" bm B = mathcalU cdot bm A","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Note this relies on a specific choice of the one-particle basis; see references. The implementation of the mathcalU coefficients in rotations3d.jl and symmetrygroups.jl is based on several numerical SVDs performed in small blocks. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The RPIBasis type stores only two fields: the PIBasis and the coefficients C.","category":"page"},{"location":"devel/#Examples","page":"Developer Docs","title":"Examples","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Invariant : varphi circ Q = varphi \nEuclideanVector : varphi circ Q = Q varphi\nEuclideanMatrix (wip) : varphi circ Q = Q varphi Q^T \nSphericalVector : varphi circ Q = D(Q) varphi\nSphericalMatrix : varphi circ Q = D(Q) varphi D(Q)^T ","category":"page"},{"location":"devel/#Specifying-the-symmetry-on-the-1-particle-basis","page":"Developer Docs","title":"Specifying the symmetry on the 1-particle basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"TODO : insert details. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"At the moment this is done manually by specifying exactly what the symmetry group is and what basis indices it is acting on. This is all very much in prototype stages and there are likely more elegant ways to implement this. For details see symmetrygroups.jl and test_multish.jl. But just to give a taster: ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"# standard / default: \nB1p = ACE.Utils.RnYlm_1pbasis(; maxdeg=maxdeg, D = D, )\nbasis = SymmetricBasis(φ, B1p, O3(), ord, maxdeg; Deg = D)\n# Ylm with different indices \nB1p_r = ACE.Utils.RnYlm_1pbasis(; maxdeg=maxdeg, D = D, \n                                   varsym = :rr, idxsyms = (:nr, :lr, :mr))\nbasis_r = SymmetricBasis(φ, B1p_r, O3(:lr, :mr), ord, maxdeg; Deg = D)\n# Magnetism without spin-orbit coupling \nB1p_r = ACE.Utils.RnYlm_1pbasis(; maxdeg=maxdeg, D = D, \n                                   varsym = :rr, idxsyms = (:nr, :lr, :mr))\nB1p_s = ACE.Ylm1pBasis(maxdeg; varsym = :ss, lsym = :ls, msym = :ms)\nbasis = SymmetricBasis(φ, B1p_r * B1p_s, O3(:lr, :mr) ⊗ O3(:ls, :ms), ord, maxdeg; Deg = D)","category":"page"},{"location":"devel/#Linear-ACE-Model","page":"Developer Docs","title":"Linear ACE Model","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A basis can be used to define a linear ACE model (and linear ACE models can then be composed to make up nonlinear ACE models, this will be discussed elsewhere.).  In ACE.jl this is achieved as follows: after constructing a basis::SymmetricBasis following the instructions above, one then has to supply a coefficient vector c. Then a linear ACE model is obtained by calling ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"model = LinearACEModel(basis, c)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"An important comment is that one can also produce multiple properties with a single basis but different coefficients. See the docstring for LinearACEModel for more details. ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"An ACE model can be evaluated as follows: ","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"evaluate(model, cfg)\ngrad_config(model, cfg) : gradient w.r.t. configurations (e.g. forces)\ngrad_params(model, cfg) : gradient w.r.t. parameters","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"We are also in the process of completing rrules for the linear ACE model so that it can be composed or incorporated into a loss and then automatically differentiated. A good place to explore how to work with LinearACEModel are test_linearmodel.jl and test_multiprop.jl.","category":"page"},{"location":"devel/#Evaluators","page":"Developer Docs","title":"Evaluators","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"TODO ","category":"page"},{"location":"purerecursion/#Pure-Basis-Recursion","page":"-","title":"Pure Basis Recursion","text":"","category":"section"},{"location":"purerecursion/","page":"-","title":"-","text":"The idea is to exploit the DAG representation of the pi-ACE basis A_bf k to recursively construct the pure basis mathcalA_bm k.","category":"page"},{"location":"purerecursion/#correlations-(2-body)","page":"-","title":"1-correlations (2-body)","text":"","category":"section"},{"location":"purerecursion/","page":"-","title":"-","text":"For the 1-correlations, there is nothing to do since","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"\n   A_k = mathcalA_k qquad forall k","category":"page"},{"location":"purerecursion/#correlations-(3-body)","page":"-","title":"2-correlations (3-body)","text":"","category":"section"},{"location":"purerecursion/","page":"-","title":"-","text":"If bm k = (k_1 k_2) then the connection bm k = (k_1) cup (k_2) is already the DAG. We can now write","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"beginaligned\n   A_k_1 k_2\n   =\n   sum_j_1 j_2 phi_k_1(bm r_j_1) phi_k_2(bm r_j_2) \n   =\n   sum_j_1 neq j_2 phi_k_1(bm r_j_1) phi_k_2(bm r_j_2)\n   + sum_j_1 phi_k_1(bm r_j_1) phi_k_2(bm r_j_1)\nendaligned","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"or, conversely,","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   mathcalA_k_1 k_2\n   =\n   A_k_1 k_2 - sum_j_1 phi_k_1(bm r_j_1) phi_k_2(bm r_j_1)","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"Next we observe that the product of polynomials phi_k_1 phi_k_2 is again a polynomial, i.e.,","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   phi_k_1 phi_k_2\n   = sum_K P_k_1 k_2^K phi_K","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"hence, we can write","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   mathcalA_k_1 k_2\n   =\n   A_k_1 k_2 - sum_K P_k_1 k_2^K A_K","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"The computation of the product coefficients P_k_1 k_2^K will be discussed  Products of Polynomials.","category":"page"},{"location":"purerecursion/#General-correlations","page":"-","title":"General correlations","text":"","category":"section"},{"location":"purerecursion/","page":"-","title":"-","text":"For general bm k = (k_1 dots k_nu), the DAG provides a recursion","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   bm k = bm k cup bm k","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"where","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   bm k = (k_1 dots k_nu) qquad\n   bm k = (k_nu+1 dots k_nu)","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"with nu = nu - nu.","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"Since we already have access to mathcalA_bm k mathcalA_bm k we can start from those objects,","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   mathcalA_bm k mathcalA_bm k\n   =\n   sum_j_1 neq dots neq j_nu\n   sum_j_nu neq cdots neq j_nu\n   prod_alpha = 1^nu phi_k_alpha(bm r_j_alpha)","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"The challenge now is to convert this into a sum_j_1 neq cdots neq j_nu. For a general recursion  bm k = bm k cup bm k this looks quite difficult.","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"Let us assume that nu leq nu then we can write","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   sum_j_1 neq dots neq j_nu\n   sum_j_nu neq cdots neq j_nu\n   =\n   sum_0 textmatches +\n   sum_1 textmatches\n   + cdots +\n   sum_nu textmatches","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"where","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   sum_p textmatches\n   =\n   sum_substack\n         j_1 neq cdots neq j_nu \n         j_nu+1 neq cdots neq j_nu \n           j_1 dots j_nu  cap j_nu+1 dots j_nu = p","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"Clearly,","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   sum_0 textmatches\n   =\n   sum_j_1 neq cdots neq j_nu","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"i.e. this is the term we want to keep. It remains to express sum_p textmatches in terms of A_bm k with mathcalA_bm k with rm len(bm k)  nu. It appears that for p there are","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   binomnup\n      cdot\n   binomnup","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"sums to evaluate. This cost clearly explodes rapidly with increasing body-order.","category":"page"},{"location":"purerecursion/#Simplified-recursion","page":"-","title":"Simplified recursion","text":"","category":"section"},{"location":"purerecursion/","page":"-","title":"-","text":"To control this cost we can replace an optimized DAG with a much simpler DAG that contains only decompositions bm k = bm k cup (k_nu+1) (note the modified notation to avoid clutter below). In this case, the term we need to manipulate is","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"beginaligned\n   mathcalA_bm k A_k_nu+1\n   =\n   sum_j_1 neq cdots neq j_nu sum_j_nu+1 prod_alpha = 1^nu+1 phi_k_alpha(r_j_alpha) \n   =\n   sum_j_1 neq cdots neq j_nu neq j_nu+1 prod_alpha = 1^nu+1 phi_k_alpha(r_j_alpha)\n   +\n   sum_beta = 1^nu sum_j_1 neq cdots neq j_nu\n      phi_k_nu+1(r_j_beta) prod_alpha = 1^nu phi_k_alpha(r_j_alpha)\nendaligned","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"We can now insert the expression for Products of Polynomials to write","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   phi_k_beta(r_j_beta) phi_k_nu+1(r_j_beta)\n   =\n   sum_K P_k_beta k_nu+1^K\n   phi_K(r_j_beta)","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"and obtain","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   mathcalA_bm k A_k_nu+1\n   =\n   mathcalA_(bm k k_nu+1)\n   +\n   sum_beta = 1^nu\n   sum_K P_k_beta k_nu+1^K\n   mathcalA_bm kbeta","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"where","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   bm kbeta = (k_1 dots k_beta-1 K k_beta+1 dots k_nu)","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"With this definition we have obtained a recursive expression the ``pure'' mathcalA  basis,","category":"page"},{"location":"purerecursion/","page":"-","title":"-","text":"   mathcalA_(bm k k_nu+1)\n   =\n   mathcalA_bm k A_k_nu+1\n   -\n   sum_beta = 1^nu\n   sum_K P_k_beta k_nu+1^K\n   mathcalA_bm kbeta","category":"page"},{"location":"docs/","page":"Types & Functions","title":"Types & Functions","text":"CurrentModule = ACE","category":"page"},{"location":"docs/#Types-and-Functions","page":"Types & Functions","title":"Types and Functions","text":"","category":"section"},{"location":"docs/#Index","page":"Types & Functions","title":"Index","text":"","category":"section"},{"location":"docs/","page":"Types & Functions","title":"Types & Functions","text":"","category":"page"},{"location":"docs/#Types","page":"Types & Functions","title":"Types","text":"","category":"section"},{"location":"docs/","page":"Types & Functions","title":"Types & Functions","text":"OneParticleBasis : part of ACEbase, not sure why; discuss. ","category":"page"},{"location":"docs/","page":"Types & Functions","title":"Types & Functions","text":"State\nDState\nACEConfig \nPIBasis\nSymmetricBasis\nLinearACEModel","category":"page"},{"location":"docs/#ACE.State","page":"Types & Functions","title":"ACE.State","text":"struct State the main type for states of input variables (particles).  This type is intended only for storing of information but no arithmetic  should be performed on it. For the latter, we have the DState.\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.DState","page":"Types & Functions","title":"ACE.DState","text":"struct DState: A State-like variable but acting like vector with arithmetic  operations defined on it, while State acts more like a fixed object that cannot  be manipulated. The main application of DState is as a derivative of a  State; see also dstate_type, ``\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.ACEConfig","page":"Types & Functions","title":"ACE.ACEConfig","text":"struct ACEConfig: The canonical implementation of an AbstractConfiguration.  Just wraps a Vector{<: AbstractState}\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.PIBasis","page":"Types & Functions","title":"ACE.PIBasis","text":"mutable struct PIBasis: implementation of a permutation-invariant basis based on the density projection trick.\n\nThe standard constructor is\n\nPIBasis(basis1p, N, D, maxdeg)\n\nbasis1p : a one-particle basis\nN : maximum interaction order\nD : an abstract degee specification, e.g., SparsePSHDegree\nmaxdeg : the maximum polynomial degree as measured by D\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.SymmetricBasis","page":"Types & Functions","title":"ACE.SymmetricBasis","text":"struct SymmetricBasis\n\nConstructors\n\nOption 1: pass a OneParticleBasis\n\nSymmetricBasis(φ, symgrp, basis1p, Bsel)\nSymmetricBasis(φ, basis1p, Bsel)   # uses default symgrp = O3()\n\nwill first construct a PIBasis from these inputs and then call the second constructor.\n\nOption 1: pass a PIBasis\n\nSymmetricBasis(φ, symgrp, pibasis)\nSymmetricBasis(φ, pibasis)\n\nIf the PIbasis is already available, this directly constructs a  resulting SymmetricBasis; all possible permutation-invariant basis functions  will be symmetrised and then reduced to a basis (rather than spanning set)\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.LinearACEModel","page":"Types & Functions","title":"ACE.LinearACEModel","text":"struct LinearACEModel: linear model for symmetric properties in terms of  a SymmetricBasis. \n\nThe typical way to construct a linear model is to first construct a basis  basis, some default coefficients c and then call \n\nmodel = LinearACEModel(basis, c)\n\nMultiple properties\n\nIf c::Vector{<: Number} then the output of the model will be the property  encoded in the basis. But one can also use a single basis to produce  multiple properties (with different coefficients). This can be achieved by  simply supplying c::Vector{SVector{N, T}} where N will then be the  number of properties. \n\n\n\n\n\n","category":"type"},{"location":"docs/#One-particle-basis-functions","page":"Types & Functions","title":"One-particle basis functions","text":"","category":"section"},{"location":"docs/","page":"Types & Functions","title":"Types & Functions","text":"Rn1pBasis\nYlm1pBasis \nScal1pBasis\ninit1pspec!","category":"page"},{"location":"docs/#ACE.Rn1pBasis","page":"Types & Functions","title":"ACE.Rn1pBasis","text":"struct Rn1pBasis <: OneParticleBasis\n\nOne-particle basis of the form R_n(r_ij), i.e., no dependence on species or on l.\n\nThis does two things: (1) translates the TransformedPolys into a valid one-particle basis; and (2) treat it as having vectorial input, i.e. value is  scalar but gradient is vectorial.\n\nThe default symbols are :rr for the state and :n for the index of the  basis function. \n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.Ylm1pBasis","page":"Types & Functions","title":"ACE.Ylm1pBasis","text":"struct Ylm1pBasis <: OneParticleBasis\n\nOne-particle basis of the form\n\nphi_lm(bm r) = Y_l^m(hatbr r)\n\nFundamental building block of ACE basis sets of the form\n\n   R_nl^mu_i mu_j(r_ij) Y_l^m(hatbm r)\n\nThis type basically just translates the SHBasis into a valid one-particle basis.\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.Scal1pBasis","page":"Types & Functions","title":"ACE.Scal1pBasis","text":"struct Scal1pBasis <: OneParticleBasis\n\nOne-particle basis of the form P_n(x_i) for a general scalar, invariant  input x. This type basically just translates the TransformedPolys into a valid one-particle basis.\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.init1pspec!","page":"Types & Functions","title":"ACE.init1pspec!","text":"function init1pspec! : initialize the specification of the 1-particle basis, generates all possible 1-p basis functions, sorted by degree.\n\n\n\n\n\n","category":"function"},{"location":"docs/#Symmetry-groups","page":"Types & Functions","title":"Symmetry groups","text":"","category":"section"},{"location":"docs/","page":"Types & Functions","title":"Types & Functions","text":"These are just currently just prototype implementations; we expect  to provide more elegant/generic and general implementations in the near  future. ","category":"page"},{"location":"docs/","page":"Types & Functions","title":"Types & Functions","text":"O3\nO3O3 ","category":"page"},{"location":"docs/#ACE.O3","page":"Types & Functions","title":"ACE.O3","text":"struct O3 <: SymmetryGroup : this is the default symmetry group; describing  the action of a single O3 group on the basis. \n\nStandard Usage: \n\nO3()\n\nwill create an O3{:l, :m} instance, i.e. the group will expect the symbols  :l, :m in the relevant 1p basis. \n\nBut if the Ylm component of the 1p basis uses different symbols then one can  tell O3 this via O3(lsym, rsym). E.g. if the variable w.r.t. which we  symmetrize is a spin s then we might call it O3(:ls, :ms). The main thing  to remember is that the symbols in the Ylm basis and in the O3 basis must  match. \n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.O3O3","page":"Types & Functions","title":"ACE.O3O3","text":"struct O3O3 <: SymmetryGroup : This type implements the O(3) otimes O(3) symmetry  group. This is useful when a particle has two euclidean vector attributes, say  bm r and bm s and the action of the group on the pair is \n\n   (Q_r Q_s) (boldsymbolr boldsymbols)  = (Q_r boldsymbolr Q_s boldsymbols)\n\nA canA canonical application is magnetism: it is known that spin-orbit coupling  is a very weak effect. By ignoring it, i.e., letting positions and spins rotate  independently of one another, one makes a small modelling error. This leads  precisely to the O(3) otimes O(3) symmetry. \n\nTo construct this group, use \n\nsymgrp = O3(:lr, :mr) ⊗ O3(:ls, :ms)\n\nor replace those symbols with the appropriate symbols used to specify the  corresponding Ylm1pbasis objects. \n\n\n\n\n\n","category":"type"},{"location":"docs/#Basis-Selectors","page":"Types & Functions","title":"Basis Selectors","text":"","category":"section"},{"location":"docs/","page":"Types & Functions","title":"Types & Functions","text":"MaxBasis\nSimpleSparseBasis\nSparseBasis","category":"page"},{"location":"docs/#ACE.MaxBasis","page":"Types & Functions","title":"ACE.MaxBasis","text":"No constraints on the basis - this selects that largest possible basis subject to additional constraints baked into the one-particle basis. In practise this should be equivalent to a naive max-norm basis selection.\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.SimpleSparseBasis","page":"Types & Functions","title":"ACE.SimpleSparseBasis","text":"struct SimpleSparseBasis:\n\nThe most basic form of a sparse basis selection, using the total degree. Only the maximum correlation order and maximum degree may be specified. This should only be used for testing.\n\n\n\n\n\n","category":"type"},{"location":"docs/#ACE.SparseBasis","page":"Types & Functions","title":"ACE.SparseBasis","text":"SparseBasis: probably the standard basis selector enabling weighted degree functions and varying degree for different correlation orders. Need to add documentation; for now look at the code for degree to see how the weight and degree dictionaries affect the definition of degree.\n\n\n\n\n\n","category":"type"},{"location":"docs/#Deeper-Internals","page":"Types & Functions","title":"Deeper Internals","text":"","category":"section"},{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(this is an early draft of this document; please send me comments!)","category":"page"},{"location":"gettingstarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Install Julia, the latest versions of ACE.jl likely requires v1.5 or higher, at the moment we don't perform rigorous tests on this. \nInstall the MolSim registry; from the Julia REPL, switch to package manager ] and then run","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"registry add https://github.com/JuliaMolSim/MolSim.git","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Install some important registered packages; from Julia REPL / package manager:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add PyCall IJulia    # add more important packages from General registry\nadd ACE              # maybe add other packages from MolSim registry","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Add other packages you think you might need, e.g. ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add PyCall IJulia\nadd JuLIP ASE ACEatoms    # for modelling with atoms and molecules","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"For fitting interatomic potenitials, you need to install also IPFitting.jl,","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add IPFitting","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Keep fingers crossed and hope it will be compatible with the current version of ACE.jl...) Other kinds of models are currently not supported by IPFitting.jl but regression must be performed \"manually\". Providing a generic regression code for ACE models is high on our priority list.","category":"page"},{"location":"gettingstarted/#Workflow","page":"Getting Started","title":"Workflow","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"For now, please see ACEsuite website for some initial examples. ","category":"page"},{"location":"envpairbasis/#Pair-Potential-with-Environment","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"","category":"section"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"To be used either as an environment-dependent pair potential for modelling PES, or as an environment-dependent bond integral for TB models.","category":"page"},{"location":"envpairbasis/#Specification-of-the-basis","page":"Pair Potential with Environment","title":"Specification of the basis","text":"","category":"section"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"The bond is defined by a vector barbm r,and the environment by vectors  bm r_j _j = 1^J. We assume that barbm r is vector between an atom at position bm 0 and barbm r. The vectors bm r_j are therefore relative to bm 0.","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"Alternatively, we could think of barbm r as describing the bond between two atoms at position pm frac12 barbm r and the bm r_j being distance vectors from bm 0 which is now the bond mid-point.","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"We think of the potential as being of the form","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   Vbig( barbm r  bm r_j _j big)\n   = sum_N sum_j_1  dots  j_N\n   V_Nbig(barbm r  bm r_j_a _a = 1^N big)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"We now construct a cylindrical coordinate system (r_j theta_j z_j) via","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"beginaligned\n  barr = barbm r \n  bm r_j = r_j cos theta_j bm e_x + r_j sintheta_j bm e_y\n               + z_j bm e_z\nendaligned","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"where the orthonormal frame bm e_x bm e_y bm e_z are defined by","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   bm e_z = fracbarbm rbar r","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"and is otherwise chosen arbitrarily. The choice of bm e_xbm e_y are therefore only unique up to a rotation about the bm e_z axis, but since all quantities of interest will be rotation-invariant, this will not affect the results. (hopefully, depends on numerical stability!)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"We now rewrite V_N in the form","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   V_N = V_Nbig(bar r  bm c_j_a _a = 1^N big)\n   qquad bm c_j = (r_j theta_j z_j)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"We expand into a polynomial basis,","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   V_N sim sum_bm k bm l bm m\n   theta_barm bm klm\n   barP_barm(barr) times prod_a = 1^N P^r_k_a(r_j_a) e^i l_a theta_j_a P^z_m_a(z_j_a)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"and apply the density trick,","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"beginaligned\n   mathcalV_N = sum_j_1  dots  j_N\n   V_Nbig(barbm r  bm r_j_a _a = 1^N big)  \n   sim\n   sum_bm k bm l bm m\n   theta_barm bm klm\n   prod_a = 1^N\n   A_barm k_a l_a m_a \n   \n   A_barm klm =\n      sum_j = 1^J phi_barmk l m(barr bm c_j) \n   phi_barmk l m(barr bm c_j)\n      = barP_barm(barr) P^r_k(r_j) e^i l theta_j P^z_m(z_j)\nendaligned","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"So we can simplify this to","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"beginaligned\n   A_barm klm\n   =\n   barP_barm(barr)\n   sum_j = 1^J\n   phi_k l m(bm c_j) \n   \n   phi_k l m(bm c_j)\n      = P^r_k(r_j) e^i l theta_j P^z_m(z_j)\nendaligned","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"This suggests the following assembly order","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   mathcalV_N\n   sim\n   sum_bm klm A_bm klm sum_bar m theta_barmbm klm barP_barm(barr)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"But this assumes that all barm have the same list of bm klm, which misses a lot of opportunity for sparsification. So if we want to keep the option to sparsify agressively, then we should keep","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"mathcalV_N\nsim\nsum_barm bm klm theta_barmbm klm barP_barm A_bm klm","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"To reduce storage one could still store the two arrays","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"      (barP_bar m)_bar m qquad (A_klm)_klm","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"separately rather than its tensor product.","category":"page"},{"location":"math/#Background-/-Formulation-of-the-Model","page":"Math","title":"Background / Formulation of the Model","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"The purpose of this section is to give a brief summary of the mathematics behind the linear ACE models.","category":"page"},{"location":"math/#Invariant-Properties","page":"Math","title":"Invariant Properties","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"To explain the main ideas in the simples non-trivial setting, we consider systems of indistinguishable particles. A configuration is an mset R =  bm r_j _j subset mathbbR^3 with arbitary numbers of particles and we wish to develop representation of properties ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"   varphibig(R) in mathbbR","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"which are invariant under permutations (already implicit in the fact that R is an mset) and under isometries O(3). To make this explicit we can write this as","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"varphibig(  Q bm r_sigma j _j big)\n=\nvarphibig(  bm r_j _j big) qquad forall Q in O(3) \nquad sigma text a permutation","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"To that end we proceed in three steps: ","category":"page"},{"location":"math/#Density-Projection-/-Atomic-Base","page":"Math","title":"Density Projection / Atomic Base","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"We define the \"atomic density\"","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"rho(bm r) = sum_j delta(bm r - bm r_j)","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"Then we choose a one-particle basis ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"phi_v(bm r) = phi_nlm(bm r) = R_n(r) Y_l^m(hatbm r)","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"and project rho` onto that basis, ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"A_v = A_nlm = langle phi_nlm rho rangle = \n   sum_j phi_nlm(bm r_j)","category":"page"},{"location":"math/#Density-correlations","page":"Math","title":"Density correlations","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"Next, we form the N-correlations of the density, rho^otimes N and project them onto the tensor project basis, ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"   bm A_bm nlm \n   = Biglangle otimes_t = 1^N phi_n_t l_t m_t rho^otimes N Bigrangle \n   = prod_t = 1^N A_n_t l_t m_t","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"The reason to introduce these is that in the next step, the symmetrisation step the density project would loose all angular information while the N-correlations retain most (though not all) of it. ","category":"page"},{"location":"math/#Symmetrisation","page":"Math","title":"Symmetrisation","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"Finally, we symmetrize the N-correlations, by integrating over the O(3)-Haar measure, ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"  B_bm nlm propto \n  int_O(3) bm A_bm nlm circ Q  dQ ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"Because of properties of the spherical harmonics one can write this as ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"  bm B = mathcalU bm A","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"where bm A is the vector of 1, 2, ..., N correlations (the maximal N is an approximation parameter!) and mathcalU is a sparse matrix (the coupling coefficients).","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"If one symmetrised all possible N-correlations then this would create a spanning set, but one can easily reduce this to an actual basis. This construction then yields a basis of the space of symmetric polynomials. ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"Notes: ","category":"page"},{"location":"math/","page":"Math","title":"Math","text":"Because of permutation symmetry only ordered bm v tuples are retained","category":"page"},{"location":"math/#General-Setting","page":"Math","title":"General Setting","text":"","category":"section"},{"location":"math/","page":"Math","title":"Math","text":"TODO: introduce the general setting with general equi-variant properties and general symmetry groups. ","category":"page"},{"location":"polyproducts/#Products-of-Polynomials","page":"-","title":"Products of Polynomials","text":"","category":"section"},{"location":"polyproducts/#Products-of-Radial-Polynomials","page":"-","title":"Products of Radial Polynomials","text":"","category":"section"},{"location":"polyproducts/","page":"-","title":"-","text":"Suppose we have a basis of orthonormal radial polynomials","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":" (J_n J_n)_w = delta_nn","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"where (cdot cdot)_w is any inner product we choose. Product J_n_1 J_n_2 are again polynomials and can therefore be expanded in terms of the basis J_nu, i.e.,","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   J_n_1 J_n_2 = sum_nu P_n_1 n_2^nu J_nu","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"Because they are orthonormal, the expansion coefficients are simply given by","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   P_n_1 n_2^nu = ( J_n_1 J_n_2 J_nu)_w","category":"page"},{"location":"polyproducts/#Implementation","page":"-","title":"Implementation","text":"","category":"section"},{"location":"polyproducts/","page":"-","title":"-","text":"The radial polynomial products are implemented in `src/polynomials/products.jl' in a lazy datastructure.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"struct OrthPolyProdCoeffs","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"If prodcoeffs::OrthPolyProdCoeffs then calling","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"P = prodcoeffs(n1, n2)","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"returns a vector P such that P[nu] is the value of P^n_1n_2_nu, allowing indices nu in mathbbZ. Coefficients outside the actual range will simply be zero. The coefficient vectors are computed lazyly, i.e., will only be precomputed when required but then stored for later use.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"The precomputation is done by explicit evaluation of the inner products as described above.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"Alternatively we can access P_n_1 n_2^nu with an iterator","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"for (nu, Pnu) in coeffs(n1, n2)\n   # ...\nend","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"will iterate only over the non-zero coefficients.","category":"page"},{"location":"polyproducts/#The-case-of-Chebyshev-Polynomials-(TODO)","page":"-","title":"The case of Chebyshev Polynomials (TODO)","text":"","category":"section"},{"location":"polyproducts/","page":"-","title":"-","text":"The simplest case is that of monomials J_n = x^n (x - x_l)^p_l (x - x_r)^p_r). The product J_n_1 J_n_2 can then by written with just five non-zero coefficients P_n_1 n_2^N. But monomials lead to sever numerical instabilities.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"The \"next-best\" option in terms of sparsity of the product coefficients appear to be Chebyshev polynomials.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   2 T_m(x) T_n(x) = T_m+n(x) + T_m-n(x)","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"That is if we choose","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   J_n = T_n+1 f_rm cut","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"then","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   J_n_1 J_n_2 = T_n_1+1 T_n_2+1 f_rm cut f_rm cut","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"For N_p = p_l + p_r we have","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   f_rm cut = sum_n = 0^N_p T_n","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"hence","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"beginaligned\n   J_n_1 J_n_2\n   =\n   sum_n = 0^N_p T_n_1+1 T_n_2+1 T_n f_rm cut \n   =\n   frac12 sum_n = 0^N_p big( T_n+1+n_2+2 + T_n_1-n_2 big) T_n f_rm cut  \n   =\n   frac12 sum_n = 0^N_p Big(\n           T_n+1+n_2+2 + n + T_n_1+n_2+2 - n\n         + T_n_1-n_2 + n + T_ n_1-n_2 - n  Big) f_rm cut\nendaligned","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"This means that there are at most 4 (N_p + 1). non-zero coefficients, independently of the chosen maximum degree.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"In practise it is quite likely that this makes little difference. We normally choose p_l = p_r = 2 which leads to approx. 20 non-zero coefficients. But this is already close to the maximum degree we allow, hence for a general basis we will see little gain. An interesting question, maybe, is whether numerical stability is improved for a Chebyshev basis because of the explicit analytic recursion.","category":"page"},{"location":"polyproducts/#Products-of-spherical-harmonics","page":"-","title":"Products of spherical harmonics","text":"","category":"section"},{"location":"polyproducts/","page":"-","title":"-","text":"A product of two spherical harmonics can again be expanded in terms of spherical harmonics,","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   Y_l_1^m_1 Y_l_2^m_2\n       = sum_lambda mu P_l_1 m_1 l_2 m_2^lambda mu Y_lambda^mu","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"where the \"coupling coefficients\" are given by","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   P_l_1 m_1 l_2 m_2^lambda mu\n   =\n   sqrtfrac(2l_1+1)(2l_2+1)2pi (2lambda+1) \n   C_l_1 m_1 l_2 m_2^LM C_l_1 0 l_2 0^L0","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"where C_l_1 m_1 l_2 m_2^LM are the Clebsch-Gordan coefficients. These are non-zero only for","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"beginaligned\n    l_1 - l_2 leq L leq l_1 + l_2 \n    M = m_1 + m_2 \n    M leq L m_i leq l_i \n    l_1 + l_2 - L text is even","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"The first three of these conditions are the conditions for C_l_1 m_1 l_2 m_2^LM to be non-zero. The fourth condition follows from the fact that","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   C_l_1 m_1 l_2 m_2^L M =\n   (-1)^l_1 + l_2 - L C_l_1 (-m_1) l_2 (-m_2)^L (-M)","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"and hence C_l_1 0 l_2 0^L0 can only be non-zero if l_1 + l_2 - L is even.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"These conditions ensure that the P_l_1 m_1 l_2 m_2^L M coefficients are extremely sparse. This is exploited when iterating over all required L M.","category":"page"},{"location":"polyproducts/#Implementation-2","page":"-","title":"Implementation","text":"","category":"section"},{"location":"polyproducts/","page":"-","title":"-","text":"The coefficients P_l_1 m_1 l_2 m_2^lambda mu are implemented in the datastructure","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"struct SHProdCoeffs","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"To get the coefficients for a specific l1, m1, l2, m2 we can call","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"P = coeffs(l1, m1, l2, m2)","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"where coeffs::SHProdCoeffs. To iterate over all non-zero coefficients,","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"for (L, M, p) in P\n   # ...\nend","category":"page"},{"location":"polyproducts/#Products-of-one-particle-basis-function","page":"-","title":"Products of one-particle basis function","text":"","category":"section"},{"location":"polyproducts/","page":"-","title":"-","text":"beginaligned\n   phi_n_1 l_1 m_1 phi_n_2 l_2 m_2\n   =\n   R_n_1 Y_l_1^m_1 R_n_2 Y_l_2^m_2  \n   =\n   sum_N P_n_1n_2^N R_N sum_L M P_l_1m_1l_2m_2^LM Y_L^M\nendaligned","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"This means we have","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   phi_k_1 phi_k_2 =\n   sum_K P_k_1 k_2^K phi_k","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"where k = (n l m) and","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   P_k_1 k_2^K = P_n_1n_2^N P_l_1m_1l_2m_2^LM","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"The tensor product structure can be exploited in code if many such products have to be computed.","category":"page"},{"location":"polyproducts/#Appendices","page":"-","title":"Appendices","text":"","category":"section"},{"location":"polyproducts/#Three-term-recurrance","page":"-","title":"Three-term recurrance","text":"","category":"section"},{"location":"polyproducts/","page":"-","title":"-","text":"If the polynomials satisfy a three-term recurrance then there is an alternative way to obtain the product coefficients which does not require evaluating the inner products. This is currently not implemented, but we keep it here as a record for the future.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"Suppose we have a radial polynomial basis satisfying the recursion","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"beginaligned\n   J_1(x) = A_1 (x - x_l)^p_l (x - x_r)^p_r \n   J_2 = (A_2 x + B_2) J_1(x) \n   J_n = (A_n x + B_n) J_n-1(x) + C_n J_n-2(x)\nendaligned","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"For the save of brevity, we will write f_rm cut = (x - x_l)^p_l (x - x_r)^p_r, o.e., J_1 = A_1 f_rm cut. The functions J_n span the space of all polynomials that are multiples of f_rm cut.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"Since f_rm cut divides all J_n, if we take a product p = J_n(x) J_n(x) then f_rm cut also divides p and in particular p = q f_rm cut. Since q is itself a polynomials it follows that","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":" p = sum_nu = 1^n+n+p_l + p_r P^n n_nu J_nu","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"for some coefficients P^nn_nu. We can determine these coefficients recursively as follows.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"beginaligned\n   sum_nu P^nn_nu J_nu = J_n J_n\n   \n   = J_n(x) (A_n x + B_n) J_n-1 + C_n J_n(x) J_n-2(x)  \n   \n   = sum_nu bigg A_n x P^nn-1_nu J_nu\n         + B_n P^nn-1_nu J_nu\n         + C_n P^nn-2_nu J_nu bigg = dots\nendaligned","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"We rewrite","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"   x J_nu  = frac1A_nu+1 J_nu+1 - fracB_nu+1A_nu+1 J_nu\n            - fracC_nu+1A_nu+1 J_nu-1","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"and insert this above, and then shift the summation indices, to obtain","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"beginaligned\n   dots\n   =\n   sum_nu bigg\n         fracA_n P^nn-1_nuA_nu+1 J_nu+1\n         - fracA_n P^nn-1_nu B_nu+1A_nu+1 J_nu\n         - fracA_n P^nn-1_nu C_nu+1A_nu+1 J_nu-1 \n    hspace2cm\n         + B_n P^nn-1_nu J_nu\n         + C_n P^nn-2_nu J_nu bigg \n   = sum_nu bigg\n         fracA_n P^nn-1_nu-1A_nu\n         - fracA_n P^nn-1_nu B_nu+1A_nu+1\n         - fracA_n P^nn-1_nu+1 C_nu+2A_nu+2\n         + B_n P^nn-1_nu\n         + C_n P^nn-2_nu bigg  J_nu  \nendaligned","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"Comparing coefficients we finally obtain","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"      P^nn_nu\n      =\n      fracA_n P^nn-1_nu-1A_nu\n      - fracA_n P^nn-1_nu B_nu+1A_nu+1\n      - fracA_n P^nn-1_nu+1 C_nu+2A_nu+2\n      + B_n P^nn-1_nu\n      + C_n P^nn-2_nu","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"This calculation is valid verbatim if n  2. Since P^nn_nu is summetric in n n we can choose whichever index n n is larger and reduce the computation of the P^nn_nu to those of smaller (n n) pairs. To treat the case n = 2 we have to make the conventions that","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"      B_1 = C_1 = C_2 = P^n0_nu = P^nn_0 = 0","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"This reduces the problem of precomputing the P^nn_nu coefficients to determining just P^11_nu.","category":"page"},{"location":"polyproducts/","page":"-","title":"-","text":"To determing P^11_nu (the start of the recursion) we simply use the procedure proposed for the general case, i.e. by evaluating the inner product. If the inner product is not available then one could simply fit to randomly selected data points or suitably chosen interpolation nodes.","category":"page"},{"location":"ad/#Preliminary-AD-Capabilities","page":"AD","title":"Preliminary AD Capabilities","text":"","category":"section"},{"location":"ad/","page":"AD","title":"AD","text":"Our aim is to make ACE.jl fully differentiable. Some first steps in this direction are now complete providing some initial AD capabilities. This page provides a preliminary documentation and records some limitations and pitfalls. ","category":"page"},{"location":"ad/","page":"AD","title":"AD","text":"Example:  ","category":"page"},{"location":"ad/","page":"AD","title":"AD","text":"# initialize the linear ACE with two invariant properties \nc_m = rand(SVector{2,Float64}, length(basis))\nmodel = ACE.LinearACEModel(basis, c_m)\n# wrap a nonlinearity around it \nFS = p -> sum( (1 .+ val.(p).^2).^0.5 )\nfsmodel = cfg -> FS(evaluate(model, cfg))\n# AD it to get the forces\ngrad_fsmodel = cfg -> Zygote.gradient(fsmodel, cfg)[1]  \n\n# now define some loss that uses model values and model gradients \ny = randn(SVector{3, Float64}, length(cfg))\nloss = model -> sum( sum(abs2, g.rr - y) \n                     for (g, y) in zip(grad_fsmodel(model, cfg), y) )\n# and we can differentiate this w.r.t the parameters\nZygote.gradient(loss, model)[1]","category":"page"},{"location":"ad/","page":"AD","title":"AD","text":"Remarks: ","category":"page"},{"location":"ad/","page":"AD","title":"AD","text":"val : evaluate(model, cfg) will return an SVector containing two Invariants. To extract an actual value from that, we use val which is simply defined as val(x) = x.val. The point though is that we also defined adjoints for val which propagage through the differentiation. This is why FS uses val in its definition. \nEspecially the AD capabilities of ACE.jl are very much a draft without much concern for performance. \ncomposition of ACE models is not supported yet, but hopefully coming. \nNobody knows what will happen in the above example if the linear ace model produces covariant instead of invariant properties :). This is all untested and will likely break. Please file issues. \nThere are a few places that are still \"hacks\", see TODOs in the main ACE.jl code. ","category":"page"},{"location":"#ACE.jl-Documentation","page":"Home","title":"ACE.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements approximation schemes for symmetric functions (including invariant scalars, equi-variant vectors and tensors ...). The origin of this effort was in modelling atomic interactions, hence the most complete implementation focus on permutations and isometries, but much of the code is more general. Extensions to other symmetries are therefore planned for the near future. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Although the original focus was on modelling atomic interactions, the scope is in principle much broader hence the ACE.jl core library is agnostic about the application domain. It provides constructions of symmetric polynomial bases. Application-specific layers are provided in the related packaged within ACEsuit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The original implemention was based on the Atomic Cluster Expansion (ACE) described in the following references:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). doi:10.1103/PhysRevB.99.014104, [html]\nM. Bachmayr, G. Csanyi, G. Dusson, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Cluster Expansion: Completeness, Efficiency and Stability. arXiv:1911.03550v3; [http] [PDF]\nDrautz, R.: Atomic cluster expansion of scalar, vectorial, and tensorial properties including magnetism and charge transfer, Phys. Rev. B 102, 024104, 2020 [http]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"gettingstarted.md\",\n         \"math.md\", \n         \"devel.md\",\n         \"ad.md\", \n         \"docs.md\", ]\nDepth = 2","category":"page"},{"location":"#Editing-and-Building-the-Documentation-Locally","page":"Home","title":"Editing and Building the Documentation Locally","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To build the documentation locally, use the make.jl script. Simply switch to ACE/docs and execute julia --project=.. make.jl, then open ./build/index.html.","category":"page"}]
}
