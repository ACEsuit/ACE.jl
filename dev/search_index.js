var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(this is an early draft of this document; please send me comments!)","category":"page"},{"location":"gettingstarted/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Install Julia, the latest versions of ACE.jl require v1.3 but should also work ok with v1.4, future versions will likely require v1.4.\nInstall the MolSim registry; from the Julia REPL, switch to package manager ] and then run","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"registry add https://github.com/JuliaMolSim/MolSim.git","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Install some important registered packages; from Julia REPL / package manager:","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add PyCall IJulia     # add more important packages from General registry\nadd JuLIP ACE ASE   # maybe add other packages from MolSim registry","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"For fitting, need to install also IPFitting.jl,","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"add IPFitting","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Keep fingers crossed and hope it will be compatible with the current version of ACE.jl...)","category":"page"},{"location":"gettingstarted/#Workflow","page":"Getting Started","title":"Workflow","text":"","category":"section"},{"location":"degree/#Notes-on-what-degree-means","page":"-","title":"Notes on what degree means","text":"","category":"section"},{"location":"degree/","page":"-","title":"-","text":"for the radial basis it seems natural that we want to use the index 1 as the first basis function and the degree is just the highest index.","category":"page"},{"location":"envpairbasis/#Pair-Potential-with-Environment","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"","category":"section"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"To be used either as an environment-dependent pair potential for modelling PES, or as an environment-dependent bond integral for TB models.","category":"page"},{"location":"envpairbasis/#Specification-of-the-basis","page":"Pair Potential with Environment","title":"Specification of the basis","text":"","category":"section"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"The bond is defined by a vector barbm r,and the environment by vectors  bm r_j _j = 1^J. We assume that barbm r is vector between an atom at position bm 0 and barbm r. The vectors bm r_j are therefore relative to bm 0.","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"Alternatively, we could think of barbm r as describing the bond between two atoms at position pm frac12 barbm r and the bm r_j being distance vectors from bm 0 which is now the bond mid-point.","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"We think of the potential as being of the form","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   Vbig( barbm r  bm r_j _j big)\n   = sum_N sum_j_1  dots  j_N\n   V_Nbig(barbm r  bm r_j_a _a = 1^N big)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"We now construct a cylindrical coordinate system (r_j theta_j z_j) via","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"beginaligned\n  barr = barbm r \n  bm r_j = r_j cos theta_j bm e_x + r_j sintheta_j bm e_y\n               + z_j bm e_z\nendaligned","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"where the orthonormal frame bm e_x bm e_y bm e_z are defined by","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   bm e_z = fracbarbm rbar r","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"and is otherwise chosen arbitrarily. The choice of bm e_xbm e_y are therefore only unique up to a rotation about the bm e_z axis, but since all quantities of interest will be rotation-invariant, this will not affect the results. (hopefully, depends on numerical stability!)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"We now rewrite V_N in the form","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   V_N = V_Nbig(bar r  bm c_j_a _a = 1^N big)\n   qquad bm c_j = (r_j theta_j z_j)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"We expand into a polynomial basis,","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   V_N sim sum_bm k bm l bm m\n   theta_barm bm klm\n   barP_barm(barr) times prod_a = 1^N P^r_k_a(r_j_a) e^i l_a theta_j_a P^z_m_a(z_j_a)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"and apply the density trick,","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"beginaligned\n   mathcalV_N = sum_j_1  dots  j_N\n   V_Nbig(barbm r  bm r_j_a _a = 1^N big)  \n   sim\n   sum_bm k bm l bm m\n   theta_barm bm klm\n   prod_a = 1^N\n   A_barm k_a l_a m_a \n   \n   A_barm klm =\n      sum_j = 1^J phi_barmk l m(barr bm c_j) \n   phi_barmk l m(barr bm c_j)\n      = barP_barm(barr) P^r_k(r_j) e^i l theta_j P^z_m(z_j)\nendaligned","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"So we can simplify this to","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"beginaligned\n   A_barm klm\n   =\n   barP_barm(barr)\n   sum_j = 1^J\n   phi_k l m(bm c_j) \n   \n   phi_k l m(bm c_j)\n      = P^r_k(r_j) e^i l theta_j P^z_m(z_j)\nendaligned","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"This suggests the following assembly order","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"   mathcalV_N\n   sim\n   sum_bm klm A_bm klm sum_bar m theta_barmbm klm barP_barm(barr)","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"But this assumes that all barm have the same list of bm klm, which misses a lot of opportunity for sparsification. So if we want to keep the option to sparsify agressively, then we should keep","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"mathcalV_N\nsim\nsum_barm bm klm theta_barmbm klm barP_barm A_bm klm","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"To reduce storage one could still store the two arrays","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"      (barP_bar m)_bar m qquad (A_klm)_klm","category":"page"},{"location":"envpairbasis/","page":"Pair Potential with Environment","title":"Pair Potential with Environment","text":"separately rather than its tensor product.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This package implements approximation schemes for permutation and isometry equi-variant functions (including invariant scalars, equi-variant vectors and tensors). Although the original focus was on modelling atomic interactions, the scope is in principle much broader hence the ACE.jl core library is agnostic about the application domain. It provides constructions of symmetric polynomial bases, imposing permutation and isometry invariance. Heavy use is made of trigonometric polynomials and spherical harmonics to impose the symmetries.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The implemention is based on the Atomic Cluster Expansion (ACE) described in the following references:","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Drautz, R.: Atomic cluster expansion for accurate and transferable interatomic potentials. Phys. Rev. B Condens. Matter. 99, 014104 (2019). doi:10.1103/PhysRevB.99.014104\nM. Bachmayr, G. Csanyi, G. Dusson, S. Etter, C. van der Oord, and C. Ortner. Atomic cluster expansion: Cluster Expansion: Completeness, Efficiency and Stability. arXiv:1911.03550v3; [http] [PDF]\nDrautz, R.: Atomic cluster expansion of scalar, vectorial, and tensorial properties including magnetism and charge transfer, Phys. Rev. B 102, 024104, 2020 [http]","category":"page"},{"location":"devel/#Developer-Documentation","page":"Developer Docs","title":"Developer Documentation","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"warning: WARNING\nThis documentation describes what will be implemented on the rewrite branch, and not what is currently implemented!","category":"page"},{"location":"devel/#Summary-of-types-and-type-hierarchy","page":"Developer Docs","title":"Summary of types and type hierarchy","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The ACE.jl package heavily utilizes composition (as opposed to inheritance), which is well aligned with Julia's type system and recommended style. Basis sets and calculators are built from the following two base types:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"OneParticleBasis : abstract supertype of a 1-particle basis\nPIBasis : concrete implementation of a permutation-invariant basis, employing a OneParticleBasis and a specification of all possible correlations\nSymmetricBasis : implementation of the \"coupling\" to achieve O(3) symmetries","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"TODO: this section could be expanded significantly","category":"page"},{"location":"devel/#States-(Input-variables)","page":"Developer Docs","title":"States (Input variables)","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Each particle is described by one or more variables, including e.g. its position, species, etc. The input space mathbbX is simply the space in which those variables reside. The input variable must be a subtype AbstractState following some strict conventions.","category":"page"},{"location":"devel/#Example","page":"Developer Docs","title":"Example","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The original ACE models interatomic interaction with each state describing one atom in terms of its (relative) position and species. In this case the state could be defined as follow:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"struct AtomState{T} <: AbstractState\n   mu::AtomicNumber\n   rr::SVector{3, T}\nend","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"It is crucial that the properties mu, rr are known to the one-particle basis, i.e. when evaluating phi_v(X) the one-particle basis phi_v must \"know\" that it can obtain the position by calling X.rr.","category":"page"},{"location":"devel/#One-Particle-Basis","page":"Developer Docs","title":"One Particle Basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A one-particle basis is a basis of functions phi_v  mathbbX to mathbbC (or, mathbbR) defined through a subtype of","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"abstract type OneParticleBasis end","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Concrete subtypes must implement the projection of the atom density onto the one-particle basis:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"  A_v(  X_j _j neq i X_i )\n   = sum_j phi_v(X_i X_j)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"where including the centre-atom X_i in the argument allows us to compute relative positions, and incorporate centre-atom information into the basis. For example, this can be used to construct a different radial basis for all species pairs, incorporating information such as atomic radii. The \"standard\" evaluation of a single phi_v(X X_0) is of course a special case. In addition, the gradients of individual basis functions, nabla phi_v(X X_0) must be provided; this gradient may be taken with respect to all continuous variables.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Assuming that basis1p isa OneParticleBasis, this is done with the following interface:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A = alloc_B(basis1p)               # allocate storage for A = [ A_z for iz=1:NZ ]\ntmp = alloc_temp(basis1p, args...)    # allocate temporary arrays\nevaluate!(A, tmp, basis1p, Xs, X0)    # fill A = [ A_z for iz=1:NZ ]","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"warning: WARNING\nThe gradient interface is not really done yet and needs some design work!","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"For the gradients the following must be provided:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"dPhi = alloc_dB(basis1p)                     # storage for (∇ϕ_k)_k\ntmpd = alloc_temp_d(basis1p, args...)        # temporary storage\nevaluate_d!(dPhi, tmpd, basis1p, X, X0)   # fill dPhi with (∇ϕ_k)_k","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The interface does not require evaluate_d!(dPhi, tmpd, basis1p, Xs, X0).","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"There is a lot of code duplication in the implementation of OneParticleBasis, which we can avoid by a generic implementation of evaluate! which loops through all X in Xs and then calls","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"add_into_A!(A, tmp, basis1p, X, X0)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"an implementation of OneParticleBasis then only needs to overload add_into_A! which evaluates all phi_v at one state pair (X, X0) and adds the basis values into a pre-allocated vector A.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The most common situation is that basis1p is a product of basis functions acting on different variables. This can be constructed using Product1pBasis. For example, a one-particle basis of the kind","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   phi_mu n l m(X) = delta(mu_X - mu) R_n(r_X) Y_l^m(bm r_X)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"can be constructed as","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Bμ = Species1PBasisCtr(species)\nRn = Rn1pBasis(ACE.Utils.radial_basis())\nYlm = Ylm1pBasis(10)\nbasis1p = Product1pBasis( (Bμ, Rn, Ylm) )","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"To build a PIBasis (see below) the OneParticleBasis musts also provide methods that specify it:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"get_spec(basis, i::Integer)   # specification of the ith basis function\nget_spec(basis)               # vector containing all basis function specs","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A basis function is specified as a NamedTuple. For instance, in the above example the values of the mu n l m indices would specify phi_mu n l m. Thus the basis function is specified by","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   b = (μ = ..., n = ..., l = ..., m = ...)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"This framework is particularly useful if some tuples overlap across different components of a product one-particle basis. For example, if R_n depends also on the species, or if the radial basis is given as R_nl.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"To let the generic code know which indices are available and what the range of each index is the one-particle basis must implement symbols and indexrange.","category":"page"},{"location":"devel/#Concrete-Implementations-of-One-particle-Bases","page":"Developer Docs","title":"Concrete Implementations of One-particle Bases","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"note: TODO\nProvide a list of all 1p-basis implementations to build from","category":"page"},{"location":"devel/#Permutation-Invariant-Basis","page":"Developer Docs","title":"Permutation-Invariant Basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The permutation-invariant basis is a concrete type","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"struct PIBasis end","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"which implements the tensor-product like basis functions","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   bm A_bm z bm k^z_0\n   =\n   prod_alpha = 1^N A_k_alpha^z_alpha z_0\n   qquad textwhere quad\n   bm z in mathbbZ^N bm k in mathbbN^N","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"as well as the gradients","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   fracpartial A_bm z bm k^z_0partial bm r_j","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The interface for this is as follows:","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"alloc_B(pibasis::PIBasis)\nalloc_tmp(pibasis::PIBasis)\nevaluate!(AA, tmp, pibasis, Rs, Zs, z0)\nalloc_dB(pibasis::PIBasis)\nalloc_tmp_d(pibasis::PIBasis)\nevaluate_d!(dAA, tmp, pibasis, Rs, Zs, z0)","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"where the storage arrays are","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"AA::Vector{<: Number} : to store any AA_kk^{zz, z0} with z0 fixed, i.e. the AA vector for a single site only. To use a PIBasis as the actual basis rather than an auxiliary one should wrap it (see bonds – TODO!)\ndAA::Matrix{<: JVec} with dimension basis-length x number of particles","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"We don't provide a detailed description here of the implementation, since it is already the final product. But we can summarize the functionality that is provided that can be used to construct further basis sets from it.","category":"page"},{"location":"devel/#Generating-a-OneParticleBasis-and-PIBasis-via-gen_sparse","page":"Developer Docs","title":"Generating a OneParticleBasis and PIBasis via gen_sparse","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"!!! note TODO       explain how the basis sets are generated, and what options there are,       discuss what a degree is etc.","category":"page"},{"location":"devel/#Properties-and-symmetries","page":"Developer Docs","title":"Properties and symmetries","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A property varphi is the output of an ACE model. Each property has certain symmetries attached to it. For example, an invariant varphi satisfies","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   varphi circ Q = varphi","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"An equivariant Euclidean vector varphi in mathbbR^3 satisfies","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   varphi circ Q = Q varphi","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"An equi-variant spherical vector varphi satisfies,","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"   varphi circ Q = D(Q) varphi","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"and there are many more options as we move to higher-order tensors.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"To model these symmetries we introduce the SymmetricBasis in the next section. To generate it a property must specify what its symmetries are.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"All properties must be subtypes of AbstractProperty. For example","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"struct InvariantT  AbstractProperty\n   valT\nend","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The actual value(s) should always be encoded in the field val since this allows for generic implementation of several methods required for properties, such as arithmetic operations.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"note: TODO\ndiscuss the interface how the properties specify their symmetry","category":"page"},{"location":"devel/#The-symmetric-basis","page":"Developer Docs","title":"The symmetric basis","text":"","category":"section"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"A key aspect of ACE.jl is to treat permutation symmetry AND O(3) symmetries. Given a propert varphi which has certain symmetries attached to it we want to generate a basis mathbfB which respects these symmetries as well. In ACE.jl this is provided by the SymmetricBasis type, which transforms from the density correlation basis mathbfA to a symmetry adapted variant by computing all possible couplings of the spherical harmonics that produce the desired symmetry.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":" bm B = C cdot bm A","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"Note this relies on a specific choice of the one-particle basis; see references. The implementation of the C coefficients in rotations3d.jl is based on a numerical SVD as opposed to an analytic SVD.","category":"page"},{"location":"devel/","page":"Developer Docs","title":"Developer Docs","text":"The RPIBasis type stores only two fields: the PIBasis and the coefficients C.","category":"page"},{"location":"pureintro/#What-is-Pure-ACE","page":"What is Pure ACE","title":"What is Pure ACE","text":"","category":"section"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"The standard ACE basis is given by the O(3)-symmetrised nu-correlations. Ignoring the O(3)-symmetry for a moment, we are talking about","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"A_bf k = prod_alpha A_k_alpha","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"where","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"   A_k = sum_j phi_k(bm r_j)","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"Another way to write this is,","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"A_bf k\n=\nsum_j_1 j_2 dots j_nu\n   prod_alpha = 1^nu\n   phi_k_alpha(bm r_j_alpha)","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"which shows the potentially unwelcome self-interaction terms.","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"On the other hand, the \"naive\" summetrised nu-order interaction is given by","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"   mathcalA_bm k =\n   frac1nu sum_sigma in S_nu phi_bm k circ sigma","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"We call this the \"pure\" ACE basis because it contains no self-interactions; indeed, another way to write it is","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"   mathcalA_bm k\n   =\n   sum_j_1  cdots  j_nu\n   prod_alpha = 1^nu\n      phi_k_alpha( bm r_j_alpha )","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"Maybe we shouldn't care about this at all, but this is far from clear. First it is chemically more intuitive to work with this basis and maybe this has some advantages in constructing or sparsifying good models. But from a purely numerical perspective there is the problem that the standard ACE basis is ill-conditioned for large body-orders.  However, if the phi_bm k are orthogonal, then this orthogonality is inherited by the mathcalB_bm k. (TODO: some subtle points - insert details)","category":"page"},{"location":"pureintro/","page":"What is Pure ACE","title":"What is Pure ACE","text":"Having an orthogonal basis has clear theoretical advantages and it gives us the opportunity to explore whether these translate also into practical advantages.","category":"page"},{"location":"purerecursion/#Pure-Basis-Recursion","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"The idea is to exploit the DAG representation of the pi-ACE basis A_bf k to recursively construct the pure basis mathcalA_bm k.","category":"page"},{"location":"purerecursion/#correlations-(2-body)","page":"Pure Basis Recursion","title":"1-correlations (2-body)","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"For the 1-correlations, there is nothing to do since","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"\n   A_k = mathcalA_k qquad forall k","category":"page"},{"location":"purerecursion/#correlations-(3-body)","page":"Pure Basis Recursion","title":"2-correlations (3-body)","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"If bm k = (k_1 k_2) then the connection bm k = (k_1) cup (k_2) is already the DAG. We can now write","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"beginaligned\n   A_k_1 k_2\n   =\n   sum_j_1 j_2 phi_k_1(bm r_j_1) phi_k_2(bm r_j_2) \n   =\n   sum_j_1 neq j_2 phi_k_1(bm r_j_1) phi_k_2(bm r_j_2)\n   + sum_j_1 phi_k_1(bm r_j_1) phi_k_2(bm r_j_1)\nendaligned","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"or, conversely,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_k_1 k_2\n   =\n   A_k_1 k_2 - sum_j_1 phi_k_1(bm r_j_1) phi_k_2(bm r_j_1)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"Next we observe that the product of polynomials phi_k_1 phi_k_2 is again a polynomial, i.e.,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   phi_k_1 phi_k_2\n   = sum_K P_k_1 k_2^K phi_K","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"hence, we can write","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_k_1 k_2\n   =\n   A_k_1 k_2 - sum_K P_k_1 k_2^K A_K","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"The computation of the product coefficients P_k_1 k_2^K will be discussed  Products of Polynomials.","category":"page"},{"location":"purerecursion/#General-correlations","page":"Pure Basis Recursion","title":"General correlations","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"For general bm k = (k_1 dots k_nu), the DAG provides a recursion","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   bm k = bm k cup bm k","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"where","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   bm k = (k_1 dots k_nu) qquad\n   bm k = (k_nu+1 dots k_nu)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"with nu = nu - nu.","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"Since we already have access to mathcalA_bm k mathcalA_bm k we can start from those objects,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_bm k mathcalA_bm k\n   =\n   sum_j_1 neq dots neq j_nu\n   sum_j_nu neq cdots neq j_nu\n   prod_alpha = 1^nu phi_k_alpha(bm r_j_alpha)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"The challenge now is to convert this into a sum_j_1 neq cdots neq j_nu. For a general recursion  bm k = bm k cup bm k this looks quite difficult.","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"Let us assume that nu leq nu then we can write","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   sum_j_1 neq dots neq j_nu\n   sum_j_nu neq cdots neq j_nu\n   =\n   sum_0 textmatches +\n   sum_1 textmatches\n   + cdots +\n   sum_nu textmatches","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"where","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   sum_p textmatches\n   =\n   sum_substack\n         j_1 neq cdots neq j_nu \n         j_nu+1 neq cdots neq j_nu \n           j_1 dots j_nu  cap j_nu+1 dots j_nu = p","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"Clearly,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   sum_0 textmatches\n   =\n   sum_j_1 neq cdots neq j_nu","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"i.e. this is the term we want to keep. It remains to express sum_p textmatches in terms of A_bm k with mathcalA_bm k with rm len(bm k)  nu. It appears that for p there are","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   binomnup\n      cdot\n   binomnup","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"sums to evaluate. This cost clearly explodes rapidly with increasing body-order.","category":"page"},{"location":"purerecursion/#Simplified-recursion","page":"Pure Basis Recursion","title":"Simplified recursion","text":"","category":"section"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"To control this cost we can replace an optimized DAG with a much simpler DAG that contains only decompositions bm k = bm k cup (k_nu+1) (note the modified notation to avoid clutter below). In this case, the term we need to manipulate is","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"beginaligned\n   mathcalA_bm k A_k_nu+1\n   =\n   sum_j_1 neq cdots neq j_nu sum_j_nu+1 prod_alpha = 1^nu+1 phi_k_alpha(r_j_alpha) \n   =\n   sum_j_1 neq cdots neq j_nu neq j_nu+1 prod_alpha = 1^nu+1 phi_k_alpha(r_j_alpha)\n   +\n   sum_beta = 1^nu sum_j_1 neq cdots neq j_nu\n      phi_k_nu+1(r_j_beta) prod_alpha = 1^nu phi_k_alpha(r_j_alpha)\nendaligned","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"We can now insert the expression for Products of Polynomials to write","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   phi_k_beta(r_j_beta) phi_k_nu+1(r_j_beta)\n   =\n   sum_K P_k_beta k_nu+1^K\n   phi_K(r_j_beta)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"and obtain","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_bm k A_k_nu+1\n   =\n   mathcalA_(bm k k_nu+1)\n   +\n   sum_beta = 1^nu\n   sum_K P_k_beta k_nu+1^K\n   mathcalA_bm kbeta","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"where","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   bm kbeta = (k_1 dots k_beta-1 K k_beta+1 dots k_nu)","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"With this definition we have obtained a recursive expression the ``pure'' mathcalA  basis,","category":"page"},{"location":"purerecursion/","page":"Pure Basis Recursion","title":"Pure Basis Recursion","text":"   mathcalA_(bm k k_nu+1)\n   =\n   mathcalA_bm k A_k_nu+1\n   -\n   sum_beta = 1^nu\n   sum_K P_k_beta k_nu+1^K\n   mathcalA_bm kbeta","category":"page"},{"location":"#ACE.jl-Documentation","page":"Home","title":"ACE.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements approximation schemes for permutation and isometry invariant functions, with focus on modelling atomic interactions. It provides constructions of symmetric polynomial bases, imposing permutation and isometry invariance. Heavy use is made of trigonometric polynomials and spherical harmonics to obtain rotation invariance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"intro.md\",\n         \"gettingstarted.md\",\n         \"devel.md\",\n         \"polyproducts.md\"]\nDepth = 1","category":"page"},{"location":"#Editing-and-Building-the-Documentation-Locally","page":"Home","title":"Editing and Building the Documentation Locally","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To build the documentation locally, use the make.jl script. Simply switch to ACE/docs and execute julia make.jl\nTo publish the documentation to github, use the publish.sh script: switch to ACE/docs and execute ./publish.sh. This will close the `ACE_gh repository (if it isn't already), the copy into it the website, and git commit, push.","category":"page"},{"location":"polyproducts/#Products-of-Polynomials","page":"Products of Polynomials","title":"Products of Polynomials","text":"","category":"section"},{"location":"polyproducts/#Products-of-Radial-Polynomials","page":"Products of Polynomials","title":"Products of Radial Polynomials","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Suppose we have a basis of orthonormal radial polynomials","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":" (J_n J_n)_w = delta_nn","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where (cdot cdot)_w is any inner product we choose. Product J_n_1 J_n_2 are again polynomials and can therefore be expanded in terms of the basis J_nu, i.e.,","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   J_n_1 J_n_2 = sum_nu P_n_1 n_2^nu J_nu","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Because they are orthonormal, the expansion coefficients are simply given by","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   P_n_1 n_2^nu = ( J_n_1 J_n_2 J_nu)_w","category":"page"},{"location":"polyproducts/#Implementation","page":"Products of Polynomials","title":"Implementation","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The radial polynomial products are implemented in `src/polynomials/products.jl' in a lazy datastructure.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"struct OrthPolyProdCoeffs","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"If prodcoeffs::OrthPolyProdCoeffs then calling","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"P = prodcoeffs(n1, n2)","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"returns a vector P such that P[nu] is the value of P^n_1n_2_nu, allowing indices nu in mathbbZ. Coefficients outside the actual range will simply be zero. The coefficient vectors are computed lazyly, i.e., will only be precomputed when required but then stored for later use.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The precomputation is done by explicit evaluation of the inner products as described above.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Alternatively we can access P_n_1 n_2^nu with an iterator","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"for (nu, Pnu) in coeffs(n1, n2)\n   # ...\nend","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"will iterate only over the non-zero coefficients.","category":"page"},{"location":"polyproducts/#The-case-of-Chebyshev-Polynomials-(TODO)","page":"Products of Polynomials","title":"The case of Chebyshev Polynomials (TODO)","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The simplest case is that of monomials J_n = x^n (x - x_l)^p_l (x - x_r)^p_r). The product J_n_1 J_n_2 can then by written with just five non-zero coefficients P_n_1 n_2^N. But monomials lead to sever numerical instabilities.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The \"next-best\" option in terms of sparsity of the product coefficients appear to be Chebyshev polynomials.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   2 T_m(x) T_n(x) = T_m+n(x) + T_m-n(x)","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"That is if we choose","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   J_n = T_n+1 f_rm cut","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"then","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   J_n_1 J_n_2 = T_n_1+1 T_n_2+1 f_rm cut f_rm cut","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"For N_p = p_l + p_r we have","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   f_rm cut = sum_n = 0^N_p T_n","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"hence","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   J_n_1 J_n_2\n   =\n   sum_n = 0^N_p T_n_1+1 T_n_2+1 T_n f_rm cut \n   =\n   frac12 sum_n = 0^N_p big( T_n+1+n_2+2 + T_n_1-n_2 big) T_n f_rm cut  \n   =\n   frac12 sum_n = 0^N_p Big(\n           T_n+1+n_2+2 + n + T_n_1+n_2+2 - n\n         + T_n_1-n_2 + n + T_ n_1-n_2 - n  Big) f_rm cut\nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"This means that there are at most 4 (N_p + 1). non-zero coefficients, independently of the chosen maximum degree.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"In practise it is quite likely that this makes little difference. We normally choose p_l = p_r = 2 which leads to approx. 20 non-zero coefficients. But this is already close to the maximum degree we allow, hence for a general basis we will see little gain. An interesting question, maybe, is whether numerical stability is improved for a Chebyshev basis because of the explicit analytic recursion.","category":"page"},{"location":"polyproducts/#Products-of-spherical-harmonics","page":"Products of Polynomials","title":"Products of spherical harmonics","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"A product of two spherical harmonics can again be expanded in terms of spherical harmonics,","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   Y_l_1^m_1 Y_l_2^m_2\n       = sum_lambda mu P_l_1 m_1 l_2 m_2^lambda mu Y_lambda^mu","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where the \"coupling coefficients\" are given by","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   P_l_1 m_1 l_2 m_2^lambda mu\n   =\n   sqrtfrac(2l_1+1)(2l_2+1)2pi (2lambda+1) \n   C_l_1 m_1 l_2 m_2^LM C_l_1 0 l_2 0^L0","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where C_l_1 m_1 l_2 m_2^LM are the Clebsch-Gordan coefficients. These are non-zero only for","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n    l_1 - l_2 leq L leq l_1 + l_2 \n    M = m_1 + m_2 \n    M leq L m_i leq l_i \n    l_1 + l_2 - L text is even","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The first three of these conditions are the conditions for C_l_1 m_1 l_2 m_2^LM to be non-zero. The fourth condition follows from the fact that","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   C_l_1 m_1 l_2 m_2^L M =\n   (-1)^l_1 + l_2 - L C_l_1 (-m_1) l_2 (-m_2)^L (-M)","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"and hence C_l_1 0 l_2 0^L0 can only be non-zero if l_1 + l_2 - L is even.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"These conditions ensure that the P_l_1 m_1 l_2 m_2^L M coefficients are extremely sparse. This is exploited when iterating over all required L M.","category":"page"},{"location":"polyproducts/#Implementation-2","page":"Products of Polynomials","title":"Implementation","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The coefficients P_l_1 m_1 l_2 m_2^lambda mu are implemented in the datastructure","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"struct SHProdCoeffs","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"To get the coefficients for a specific l1, m1, l2, m2 we can call","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"P = coeffs(l1, m1, l2, m2)","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where coeffs::SHProdCoeffs. To iterate over all non-zero coefficients,","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"for (L, M, p) in P\n   # ...\nend","category":"page"},{"location":"polyproducts/#Products-of-one-particle-basis-function","page":"Products of Polynomials","title":"Products of one-particle basis function","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   phi_n_1 l_1 m_1 phi_n_2 l_2 m_2\n   =\n   R_n_1 Y_l_1^m_1 R_n_2 Y_l_2^m_2  \n   =\n   sum_N P_n_1n_2^N R_N sum_L M P_l_1m_1l_2m_2^LM Y_L^M\nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"This means we have","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   phi_k_1 phi_k_2 =\n   sum_K P_k_1 k_2^K phi_k","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"where k = (n l m) and","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   P_k_1 k_2^K = P_n_1n_2^N P_l_1m_1l_2m_2^LM","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"The tensor product structure can be exploited in code if many such products have to be computed.","category":"page"},{"location":"polyproducts/#Appendices","page":"Products of Polynomials","title":"Appendices","text":"","category":"section"},{"location":"polyproducts/#Three-term-recurrance","page":"Products of Polynomials","title":"Three-term recurrance","text":"","category":"section"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"If the polynomials satisfy a three-term recurrance then there is an alternative way to obtain the product coefficients which does not require evaluating the inner products. This is currently not implemented, but we keep it here as a record for the future.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Suppose we have a radial polynomial basis satisfying the recursion","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   J_1(x) = A_1 (x - x_l)^p_l (x - x_r)^p_r \n   J_2 = (A_2 x + B_2) J_1(x) \n   J_n = (A_n x + B_n) J_n-1(x) + C_n J_n-2(x)\nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"For the save of brevity, we will write f_rm cut = (x - x_l)^p_l (x - x_r)^p_r, o.e., J_1 = A_1 f_rm cut. The functions J_n span the space of all polynomials that are multiples of f_rm cut.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Since f_rm cut divides all J_n, if we take a product p = J_n(x) J_n(x) then f_rm cut also divides p and in particular p = q f_rm cut. Since q is itself a polynomials it follows that","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":" p = sum_nu = 1^n+n+p_l + p_r P^n n_nu J_nu","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"for some coefficients P^nn_nu. We can determine these coefficients recursively as follows.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   sum_nu P^nn_nu J_nu = J_n J_n\n   \n   = J_n(x) (A_n x + B_n) J_n-1 + C_n J_n(x) J_n-2(x)  \n   \n   = sum_nu bigg A_n x P^nn-1_nu J_nu\n         + B_n P^nn-1_nu J_nu\n         + C_n P^nn-2_nu J_nu bigg = dots\nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"We rewrite","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"   x J_nu  = frac1A_nu+1 J_nu+1 - fracB_nu+1A_nu+1 J_nu\n            - fracC_nu+1A_nu+1 J_nu-1","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"and insert this above, and then shift the summation indices, to obtain","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"beginaligned\n   dots\n   =\n   sum_nu bigg\n         fracA_n P^nn-1_nuA_nu+1 J_nu+1\n         - fracA_n P^nn-1_nu B_nu+1A_nu+1 J_nu\n         - fracA_n P^nn-1_nu C_nu+1A_nu+1 J_nu-1 \n    hspace2cm\n         + B_n P^nn-1_nu J_nu\n         + C_n P^nn-2_nu J_nu bigg \n   = sum_nu bigg\n         fracA_n P^nn-1_nu-1A_nu\n         - fracA_n P^nn-1_nu B_nu+1A_nu+1\n         - fracA_n P^nn-1_nu+1 C_nu+2A_nu+2\n         + B_n P^nn-1_nu\n         + C_n P^nn-2_nu bigg  J_nu  \nendaligned","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"Comparing coefficients we finally obtain","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"      P^nn_nu\n      =\n      fracA_n P^nn-1_nu-1A_nu\n      - fracA_n P^nn-1_nu B_nu+1A_nu+1\n      - fracA_n P^nn-1_nu+1 C_nu+2A_nu+2\n      + B_n P^nn-1_nu\n      + C_n P^nn-2_nu","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"This calculation is valid verbatim if n  2. Since P^nn_nu is summetric in n n we can choose whichever index n n is larger and reduce the computation of the P^nn_nu to those of smaller (n n) pairs. To treat the case n = 2 we have to make the conventions that","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"      B_1 = C_1 = C_2 = P^n0_nu = P^nn_0 = 0","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"This reduces the problem of precomputing the P^nn_nu coefficients to determining just P^11_nu.","category":"page"},{"location":"polyproducts/","page":"Products of Polynomials","title":"Products of Polynomials","text":"To determing P^11_nu (the start of the recursion) we simply use the procedure proposed for the general case, i.e. by evaluating the inner product. If the inner product is not available then one could simply fit to randomly selected data points or suitably chosen interpolation nodes.","category":"page"}]
}
